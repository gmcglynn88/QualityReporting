<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>QA Evaluations – Monthly View</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root{
      --primary-color:#63AB8F; --secondary-color:#4A8C7D; --border-color:#DEE2E6;
      --light-bg:#F8F9FA; --card-bg:#FFFFFF; --text-color:#2C3E50; --text-light:#6C757D;
      --pill:#e9f6f0;
    }
    body{
      font-family:'Aptos','Segoe UI',system-ui,-apple-system,Arial,sans-serif;
      margin:20px;padding:20px;max-width:1400px;background:var(--light-bg);color:var(--text-color)
    }
    #logo-container{text-align:center;margin-bottom:20px} #logo{width:300px}
    h1{margin:0 0 16px}
    .card{background:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:24px;margin-top:16px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    label{display:block;font-weight:600;margin-bottom:6px}
    input,select,button,textarea{padding:10px;border:1px solid var(--border-color);border-radius:6px;background:#fff;font-size:14px}
    button{background:var(--primary-color);color:#fff;font-weight:600;cursor:pointer;transition:background .2s}
    button:hover{background:var(--secondary-color)} button:disabled{background:var(--text-light);cursor:not-allowed}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;align-items:start}
    .full-width-btn{width:100%;padding:14px 18px;font-size:16px;margin-top:12px}
    .muted{color:var(--text-light);font-size:12px}
    .section-title{margin:0 0 10px;color:var(--secondary-color)}

    #messageContainer{display:none;margin-top:12px}
    .error-message{color:#b4231a;background:#fee2e2;border:1px solid #fecaca;padding:10px;border-radius:6px}
    .success-message{color:#14532d;background:#dcfce7;border:1px solid #bbf7d0;padding:10px;border-radius:6px}
    .info-message{color:#6b4e16;background:#fff7ed;border:1px solid #ffedd5;padding:10px;border-radius:6px}

    table { width: 100%; border-collapse: collapse; margin-top: 12px; border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: top; }
    th { background-color: var(--primary-color); color: white; font-weight: 600; }
    tr:hover { background-color: rgba(99, 171, 143, 0.05); }
    .subheader { background: rgba(99,171,143,.15); font-weight: 600; }
    .table-container { overflow-x: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 1px; margin-top: 10px; }

    .tab { display: inline-block; padding: 12px 20px; margin-right: 10px; background: #eee; cursor: pointer; border-radius: 6px; font-weight: 500; }
    .tab.active { background: var(--primary-color); color: white; font-weight: 600; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    .badge { display:inline-block; padding:2px 8px; border-radius:12px; font-size:12px; border:1px solid var(--border-color); background:#fff }
    .badge-critical { color:#b4231a; border-color:#fecaca; background:#fee2e2 }
    .badge-fatal { color:#fff; background:#b4231a; border-color:#b4231a; }
    .badge-ok { color:#14532d; background:#dcfce7; border-color:#bbf7d0 }
    details.evaluation { border:1px solid var(--border-color); border-radius:8px; padding:10px; margin:10px 0; background:#fff }
    details.evaluation summary { cursor:pointer; font-weight:600 }

    .kpis { display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap:10px; margin-top:10px }
    .kpi { background:#fff; border:1px solid var(--border-color); border-radius:8px; padding:12px; }
    .kpi .label { color:var(--text-light); font-size:12px }
    .kpi .value { font-size:20px; font-weight:700; margin-top:4px }

    /* Checkbox dropdown styles */
    .checkbox-dropdown{position:relative;min-width:220px;width:100%}
    .cd-trigger{display:flex;align-items:center;justify-content:space-between;border:1px solid var(--border-color);border-radius:6px;background:#fff;padding:10px;cursor:pointer;width:100%;box-sizing:border-box}
    .cd-trigger .label{color:var(--text-color);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1}
    .cd-trigger .count{background:var(--pill);border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;color:#2c3e50;flex-shrink:0;margin-left:8px}
    .cd-panel{position:absolute;z-index:1000;margin-top:6px;background:#fff;border:1px solid var(--border-color);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.12);width:100%;max-height:340px;overflow:hidden;display:none;box-sizing:border-box}
    .cd-panel.open{display:block}
    .cd-header{padding:10px;border-bottom:1px solid var(--border-color);display:flex;gap:8px;align-items:center}
    .cd-search{flex:1;border:1px solid var(--border-color);border-radius:6px;padding:8px;width:100%;box-sizing:border-box}
    .cd-actions{display:flex;gap:8px}
    .cd-actions button{background:#eef6f2;color:#2c3e50;border:1px solid var(--border-color);border-radius:6px;padding:8px 10px;cursor:pointer;white-space:nowrap}
    .cd-selectall{padding:8px 12px;border-bottom:1px solid var(--border-color);display:flex;align-items:center;gap:10px}
    .cd-list{max-height:260px;overflow:auto}
    .cd-item{display:flex;align-items:center;gap:10px;padding:8px 12px;border-bottom:1px solid #f1f3f5}
    .cd-item label{display:flex;align-items:center;gap:10px;cursor:pointer;width:100%}
    .cd-footer{padding:8px 12px;background:#fafafa;border-top:1px solid var(--border-color);font-size:12px;color:var(--text-light);display:flex;justify-content:space-between}
    
    /* Responsive */
    @media (max-width: 1200px) { .controls { grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); } }
    @media (max-width: 768px) { .controls { grid-template-columns: 1fr; } }

    .loading-spinner { display: inline-block; width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin-right: 8px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .comment-bubble { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 12px; padding: 8px 12px; margin-top: 4px; font-size: 12px; color: #6c757d; }

    /* Row highlighting for critical and fatal questions */
    tr.critical-warning { background-color: #fffbeb !important; border-left: 4px solid #f59e0b; }
    tr.fatal-question { background-color: #fef2f2 !important; border-left: 4px solid #dc2626; }
    tr.critical-warning:hover { background-color: #fef3c7 !important; }
    tr.fatal-question:hover { background-color: #fecaca !important; }

    .question-group-header { background-color: rgba(99, 171, 143, 0.1); font-weight: 600; font-size: 14px; padding: 8px 12px; border-left: 4px solid var(--primary-color); }
  </style>
</head>
<body>
  <div id="logo-container">
    <img id="logo" src="https://raw.githubusercontent.com/gmcglynn88/Management-Unit-Search/main/Consultinglogo%20(2).png" alt="Company Logo">
  </div>

  <h1>QA Evaluations – Monthly View</h1>

  <div id="authCard" class="card">
    <div id="auth-message" class="info-message">Authenticating with PureCloud...</div>
  </div>

  <!-- Debug (add ?debug=1 to the URL) -->
  <div id="authDebug" class="card" style="display:none">
    <h2 class="section-title">Auth debug</h2>
    <pre id="authDump" style="background:#f6f8fa;border:1px solid #eee;padding:12px;border-radius:8px;overflow:auto"></pre>
    <button id="signinBtn">Sign in with Genesys</button>
  </div>

  <div id="appContent" style="display:none;">
    <div id="messageContainer"></div>

    <div class="card">
      <h2 class="section-title">Configuration</h2>
      <div class="controls">
        <div>
          <label for="userDropdown">Agents (Optional)</label>
          <div id="userDropdown" class="checkbox-dropdown"></div>
          <div class="muted">Select agents to filter by, or leave empty for all</div>
        </div>
        <div>
          <label for="formDropdown">Evaluation Forms (Optional)</label>
          <div id="formDropdown" class="checkbox-dropdown"></div>
          <div class="muted">Select forms to filter by, or leave empty for all</div>
        </div>
        <div>
          <label for="monthInput">Month</label>
          <input id="monthInput" type="month">
          <div class="muted">Evaluations within the selected month</div>
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="loadBtn" class="full-width-btn" disabled>
            <span class="loading-spinner" style="display:none"></span>
            <span class="btn-text">Load Evaluations</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="card">
      <div style="margin-bottom: 10px;">
        <div id="tabs">
          <div id="overviewTabButton" class="tab active">Overview</div>
          <div id="trendsTabButton" class="tab">Agent Trends</div>
          <div id="detailsTabButton" class="tab">Evaluation Details</div>
          <div id="criticalTabButton" class="tab">Critical / Fatal Summary</div>
        </div>
      </div>

      <div id="overviewTab" class="tab-content active">
        <h2 class="section-title">Monthly Overview</h2>
        <div id="overviewKPIs" class="kpis"></div>
        <div class="table-container">
          <table id="agentSummaryTable"></table>
        </div>
      </div>

      <div id="trendsTab" class="tab-content">
        <h2 class="section-title">Daily Trend by Agent</h2>
        <div class="table-container">
          <table id="trendTable"></table>
        </div>
      </div>

      <div id="detailsTab" class="tab-content">
        <h2 class="section-title">Evaluation Details (with Question Scores)</h2>
        <div id="detailsContainer"></div>
      </div>

      <div id="criticalTab" class="tab-content">
        <h2 class="section-title">Critical / Kill Question Counts</h2>
        <div class="table-container">
          <table id="criticalTable"></table>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== OAuth Configuration =====
    const clientId = 'fe305808-b368-4547-8af9-325d28d552bb';
    const config = { REGION: 'mypurecloud.ie' };
    const DEBUG = new URLSearchParams(window.location.search).has('debug');

    // Use explicit redirect URI for GitHub Pages
    const redirectUri = 'https://gmcglynn88.github.io/QualityReporting/';
    const oauthUrl = `https://login.${config.REGION}/oauth/authorize?client_id=${encodeURIComponent(clientId)}&response_type=token&redirect_uri=${encodeURIComponent(redirectUri)}&state=qa`;

    console.log('OAuth Configuration:', {
      clientId,
      region: config.REGION,
      redirectUri,
      currentPath: window.location.pathname
    });

    const state = {
      accessToken: null,
      users: [],                 // [{id, name, email}]
      forms: [],                 // [{id, name, questionsById}]
      formsById: {},             // id -> form
      evals: [],                 // loaded evaluations
      monthStart: null,
      monthEnd: null,
      formDetailsCache: new Map()   // Cache for complete form details
    };

    // Checkbox dropdown instances
    const dropdowns = {
      users: null,
      forms: null
    };

    // Rate limiting
    let lastApiCall = 0;
    const API_DELAY = 100; // ms between API calls to avoid rate limits

    function showDebugCard() {
      const debugInfo = {
        clientId: clientId,
        region: config.REGION,
        redirectUri: redirectUri,
        currentUrl: window.location.href,
        oauthUrl: oauthUrl,
        sessionToken: sessionStorage.getItem('purecloud_token') ? 'Present' : 'Missing',
        urlHash: window.location.hash || 'None'
      };
      
      document.getElementById('authDebug').style.display = 'block';
      document.getElementById('authDump').textContent = JSON.stringify(debugInfo, null, 2);
      document.getElementById('signinBtn').onclick = () => {
        console.log('Manual OAuth redirect');
        window.location.href = oauthUrl;
      };
      
      document.getElementById('auth-message').textContent = 'Debug mode: Check configuration and click "Sign in with Genesys"';
    }
    
    function msg(html, type='info'){ 
      const box=document.getElementById('messageContainer'); 
      box.innerHTML=`<div class="${type}-message">${html}</div>`; 
      box.style.display='block'; 
      if(type==='success'){ 
        setTimeout(()=>box.style.display='none',5000);
      } 
    }

    function setLoading(button, isLoading) {
      const spinner = button.querySelector('.loading-spinner');
      const text = button.querySelector('.btn-text');
      if (isLoading) {
        spinner.style.display = 'inline-block';
        text.textContent = 'Loading...';
        button.disabled = true;
      } else {
        spinner.style.display = 'none';
        text.textContent = 'Load Evaluations';
        button.disabled = false;
      }
    }

    // ===== Checkbox Dropdown Component =====
    function createCheckboxDropdown(containerId, { placeholder, searchPlaceholder }){
      const root = document.getElementById(containerId);
      root.innerHTML = '';

      const trigger = document.createElement('div');
      trigger.className = 'cd-trigger';
      trigger.innerHTML = `<span class="label">${placeholder}</span><span class="count">0 selected</span>`;
      root.appendChild(trigger);

      const panel = document.createElement('div');
      panel.className = 'cd-panel';
      panel.innerHTML = `
        <div class="cd-header">
          <input type="text" class="cd-search" placeholder="${searchPlaceholder}" />
          <div class="cd-actions">
            <button type="button" data-cd="clear">Clear</button>
          </div>
        </div>
        <div class="cd-selectall">
          <label><input type="checkbox" data-cd="selectall"/> Select all</label>
        </div>
        <div class="cd-list"></div>
        <div class="cd-footer">
          <span data-cd="summary">0 selected</span>
          <span>Click outside to close</span>
        </div>
      `;
      root.appendChild(panel);

      const list = panel.querySelector('.cd-list');
      const search = panel.querySelector('.cd-search');
      const clearBtn = panel.querySelector('[data-cd="clear"]');
      const selectAll = panel.querySelector('[data-cd="selectall"]');
      const summary = panel.querySelector('[data-cd="summary"]');

      let options = []; // [{value, label}]
      let selected = new Set();

      function render(filter=''){
        const ft = filter.trim().toLowerCase();
        list.innerHTML = '';
        const filtered = !ft ? options : options.filter(o => (o.label||'').toLowerCase().includes(ft));
        if (!filtered.length){ list.innerHTML = `<div class="cd-item" style="color:#6C757D">No matches</div>`; return; }
        filtered.forEach(o=>{
          const id = `${containerId}__${o.value}`;
          const row = document.createElement('div');
          row.className = 'cd-item';
          row.innerHTML = `
            <label for="${id}">
              <input type="checkbox" id="${id}" value="${o.value}" ${selected.has(o.value)?'checked':''}/>
              <span>${o.label || o.value}</span>
            </label>
          `;
          const cb = row.querySelector('input');
          cb.addEventListener('change', ()=>{
            if (cb.checked) selected.add(o.value); else selected.delete(o.value);
            updateSummary(); updateSelectAllState();
            updateLoadButtonState();
          });
          list.appendChild(row);
        });
      }
      
      function updateSummary(){
        trigger.querySelector('.count').textContent = `${selected.size} selected`;
        summary.textContent = `${selected.size} selected`;
      }
      
      function updateSelectAllState(){
        const total = options.length, count = selected.size;
        selectAll.indeterminate = count>0 && count<total;
        selectAll.checked = total>0 && count===total;
      }

      trigger.addEventListener('click', ()=>{ panel.classList.toggle('open'); search.focus(); });
      document.addEventListener('click', (e)=>{ if (!root.contains(e.target)) panel.classList.remove('open'); });
      search.addEventListener('input', ()=> render(search.value));
      clearBtn.addEventListener('click', ()=>{ selected.clear(); render(search.value); updateSummary(); updateSelectAllState(); updateLoadButtonState(); });
      selectAll.addEventListener('change', ()=>{
        if (selectAll.checked) options.forEach(o=> selected.add(o.value)); else selected.clear();
        render(search.value); updateSummary(); updateLoadButtonState();
      });

      function setOptions(newOptions){
        options = newOptions || [];
        selected.forEach(v=>{ if (!options.some(o=>o.value===v)) selected.delete(v); });
        render(search.value); updateSummary(); updateSelectAllState();
        updateLoadButtonState();
      }
      
      function getSelectedValues(){ return Array.from(selected); }

      render('');
      return { setOptions, getSelectedValues };
    }

    function updateLoadButtonState(){
      const hasMonth = document.getElementById('monthInput').value;
      // Either agents or forms or both can be selected, but at least one selection is required
      const hasUsers = dropdowns.users && dropdowns.users.getSelectedValues().length > 0;
      const hasForms = dropdowns.forms && dropdowns.forms.getSelectedValues().length > 0;
      document.getElementById('loadBtn').disabled = !(hasMonth && (hasUsers || hasForms));
    }

    // ===== Improved Authentication Handler =====
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, checking authentication...');
      
      // Check URL hash first (OAuth callback)
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      const tokenFromHash = params.get('access_token');
      
      if (tokenFromHash) {
        console.log('✓ Token received via OAuth callback');
        sessionStorage.setItem('purecloud_token', tokenFromHash);
        // Clean URL - remove hash
        history.replaceState(null, document.title, window.location.pathname + window.location.search);
        startApp(tokenFromHash);
        return;
      }
      
      // Check existing session
      const tokenFromSession = sessionStorage.getItem('purecloud_token');
      if (tokenFromSession) {
        console.log('✓ Using existing session token');
        startApp(tokenFromSession);
        return;
      }
      
      // No token - need authentication
      console.log('✗ No token found, starting OAuth flow');
      
      if (DEBUG) {
        showDebugCard();
      } else {
        // Auto-redirect with user feedback
        const authMsg = document.getElementById('auth-message');
        authMsg.textContent = 'Redirecting to Genesys Cloud for authentication...';
        authMsg.className = 'info-message';
        
        setTimeout(() => {
          console.log('Redirecting to:', oauthUrl);
          window.location.href = oauthUrl;
        }, 1500);
      }
    });

    function startApp(token){
      console.log('Starting app with token');
      state.accessToken = token;
      
      document.getElementById('auth-message').textContent = 'Authenticated successfully!';
      document.getElementById('auth-message').className = 'success-message';
      setTimeout(()=>{ 
        document.getElementById('authCard').style.display='none'; 
        document.getElementById('authDebug').style.display='none'; 
      }, 1200);

      document.getElementById('appContent').style.display='block';

      // Initialize dropdowns
      dropdowns.users = createCheckboxDropdown('userDropdown', { 
        placeholder: 'Select agents (optional)', 
        searchPlaceholder: 'Search agents...' 
      });
      dropdowns.forms = createCheckboxDropdown('formDropdown', { 
        placeholder: 'Select forms (optional)', 
        searchPlaceholder: 'Search forms...' 
      });

      // Wire controls
      document.getElementById('overviewTabButton').onclick = () => setTab('overview');
      document.getElementById('trendsTabButton').onclick = () => setTab('trends');
      document.getElementById('detailsTabButton').onclick = () => setTab('details');
      document.getElementById('criticalTabButton').onclick = () => setTab('critical');
      document.getElementById('loadBtn').onclick = loadEvaluations;

      // Default month = current month
      const m = new Date();
      document.getElementById('monthInput').value = `${m.getFullYear()}-${String(m.getMonth()+1).padStart(2,'0')}`;
      updateMonthRange();

      document.getElementById('monthInput').addEventListener('change', () => {
        updateMonthRange();
        updateLoadButtonState();
      });

      // Load lookups
      Promise.all([fetchAllUsers(), fetchAllForms()])
        .then(()=> { 
          console.log('Lookups loaded successfully');
          updateLoadButtonState();
        })
        .catch(err => {
          console.error('Initial load failed:', err);
          msg('Initial load failed: '+err.message,'error');
        });
    }

    function setTab(name){
      ['overview','trends','details','critical'].forEach(n=>{
        document.getElementById(`${n}Tab`).classList.toggle('active', n===name);
        document.getElementById(`${n}TabButton`).classList.toggle('active', n===name);
      });
    }

    function updateMonthRange(){
      const val = document.getElementById('monthInput').value; // yyyy-mm
      if(!val) return;
      const [y,m] = val.split('-').map(Number);
      state.monthStart = new Date(Date.UTC(y, m-1, 1, 0, 0, 0));
      state.monthEnd   = new Date(Date.UTC(y, m, 0, 23, 59, 59));
      console.log('Month range updated:', state.monthStart, 'to', state.monthEnd);
    }

    // ===== API Helpers =====
    async function rateLimitedFetch(url, options = {}) {
      const now = Date.now();
      const timeSinceLastCall = now - lastApiCall;
      
      if (timeSinceLastCall < API_DELAY) {
        await new Promise(resolve => setTimeout(resolve, API_DELAY - timeSinceLastCall));
      }
      
      lastApiCall = Date.now();
      return fetch(url, {
        ...options,
        headers: {
          'Authorization': 'Bearer ' + state.accessToken,
          'Content-Type': 'application/json',
          ...options.headers
        }
      });
    }

    async function fetchPaginatedGET(url){
      console.log('Fetching:', url);
      let all = [];
      let next = url;
      while(next){
        const res = await rateLimitedFetch(next);
        if(!res.ok) {
          console.error('Fetch failed:', res.status, res.statusText);
          throw new Error(`HTTP ${res.status} for ${next}`);
        }
        const data = await res.json();
        
        if (Array.isArray(data.entities)) all = all.concat(data.entities);
        else if (Array.isArray(data.users)) all = all.concat(data.users);
        else if (Array.isArray(data)) all = all.concat(data);
        else if (data.entities) all = all.concat(data.entities);
        
        // next page
        if (data.nextUri) next = `https://api.${config.REGION}${data.nextUri}`;
        else next = null;
      }
      console.log(`Fetched ${all.length} items`);
      return all;
    }

    function safeGet(obj, path, def=null){
      try{ 
        return path.split('.').reduce((o,k)=> (o && k in o) ? o[k] : undefined , obj) ?? def; 
      } catch(e) { 
        return def; 
      }
    }

    function pct(n, digits=1){ if(n===null||n===undefined||!isFinite(n)) return '-'; return (Math.round(n*10**digits)/10**digits).toFixed(digits)+'%'; }
    function fmt(n, digits=1){ if(n===null||n===undefined||!isFinite(n)) return '-'; return (Math.round(n*10**digits)/10**digits).toFixed(digits); }
    function toUKDate(d){ const dt = new Date(d); return dt.toLocaleDateString('en-GB'); }
    function dayKeyUTC(d){ const dt = new Date(d); return new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate())).toISOString().split('T')[0]; }

    // ===== Lookups =====
    async function fetchAllUsers(){
      try {
        const url = `https://api.${config.REGION}/api/v2/users?pageSize=100`;
        const users = await fetchPaginatedGET(url);
        state.users = users.map(u => ({ 
          id: u.id, 
          name: (u.name || `${u.givenName||''} ${u.familyName||''}`).trim(), 
          email: u.email || '' 
        })).sort((a,b)=>a.name.localeCompare(b.name));
        
        // Populate the users dropdown
        const userOptions = state.users.map(u => ({ 
          value: u.id, 
          label: `${u.name}${u.email ? ` — ${u.email}` : ''}` 
        }));
        dropdowns.users.setOptions(userOptions);
        console.log(`Loaded ${state.users.length} users`);
      } catch (error) {
        console.error('Error fetching users:', error);
        throw error;
      }
    }

    async function fetchAllForms(){
      try {
        const url = `https://api.${config.REGION}/api/v2/quality/forms/evaluations?pageSize=100`;
        const forms = await fetchPaginatedGET(url);
        state.forms = forms.map(f => ({
          id: f.id, 
          name: f.name || f.title || '(Unnamed form)'
        })).sort((a,b)=>a.name.localeCompare(b.name));
        
        state.formsById = Object.fromEntries(state.forms.map(f=>[f.id,f]));
        
        // Populate the forms dropdown
        const formOptions = state.forms.map(f => ({ 
          value: f.id, 
          label: f.name 
        }));
        dropdowns.forms.setOptions(formOptions);
        console.log(`Loaded ${state.forms.length} forms`);
      } catch (error) {
        console.error('Error fetching forms:', error);
        throw error;
      }
    }

    // ===== Query Evaluations =====
    async function loadEvaluations(){
      const agentIds = dropdowns.users.getSelectedValues();
      const formIds = dropdowns.forms.getSelectedValues();

      // Either agents or forms must be selected (or both)
      if (agentIds.length === 0 && formIds.length === 0) { 
        msg('Please select at least one agent or form.','error'); 
        return; 
      }
      if (!state.monthStart || !state.monthEnd) { 
        msg('Please select a month.','error'); 
        return; 
      }

      const loadBtn = document.getElementById('loadBtn');
      setLoading(loadBtn, true);
      msg('Loading evaluations…','info');
      
      try {
        // Use only the detailed evaluations API
        console.log('Loading detailed evaluations...');
        state.evals = await fetchDetailedEvaluations(agentIds, formIds);
        
        console.log(`Loaded ${state.evals.length} detailed evaluations`);
        msg(`Loaded ${state.evals.length} evaluations.`, 'success');
        renderAll();
      } catch(e) {
        console.error('Error loading evaluations:', e);
        msg('Failed to load evaluations: '+e.message,'error');
      } finally {
        setLoading(loadBtn, false);
      }
    }

    async function fetchDetailedEvaluations(agentIds, formIds) {
      const allEvaluations = [];
      
      // If no agents selected but forms are selected, we need to get all users first
      let agentsToQuery = agentIds;
      if (agentIds.length === 0 && formIds.length > 0) {
        console.log('No agents selected, but forms selected. Getting all users first...');
        agentsToQuery = state.users.map(u => u.id);
      }
      
      // Process agents in batches to avoid overwhelming the API
      const batchSize = 5;
      for (let i = 0; i < agentsToQuery.length; i += batchSize) {
        const batch = agentsToQuery.slice(i, i + batchSize);
        console.log(`Processing batch ${i/batchSize + 1} of ${Math.ceil(agentsToQuery.length/batchSize)}`);
        
        const batchPromises = batch.map(agentId => 
          fetchEvaluationsForAgent(agentId, formIds)
        );
        
        const batchResults = await Promise.all(batchPromises);
        batchResults.forEach(evaluations => {
          allEvaluations.push(...evaluations);
        });
        
        // Small delay between batches
        if (i + batchSize < agentsToQuery.length) {
          await new Promise(resolve => setTimeout(resolve, 200));
        }
      }
      
      return allEvaluations;
    }

    async function fetchEvaluationsForAgent(agentId, formIds) {
      const start = state.monthStart.toISOString();
      const end = state.monthEnd.toISOString();
      
      const baseUrl = `https://api.${config.REGION}/api/v2/quality/evaluations/query`;
      const params = new URLSearchParams({
        agentUserId: agentId,
        startTime: start,
        endTime: end,
        expandAnswerTotalScores: 'true',
        pageSize: '50'
      });

      if (formIds && formIds.length > 0) {
        if (formIds.length === 1) {
          params.set('formId', formIds[0]);
        }
      }

      let allEvaluations = [];
      let nextUrl = `${baseUrl}?${params.toString()}`;

      while (nextUrl) {
        const res = await rateLimitedFetch(nextUrl);
        
        if (!res.ok) {
          // If GET fails, try POST method
          if (res.status === 400 || res.status === 405) {
            console.log('GET failed, trying POST method...');
            const postResults = await fetchEvaluationsViaPOST(agentId, formIds);
            return postResults;
          }
          throw new Error(`Failed to fetch evaluations: ${res.status}`);
        }

        const data = await res.json();
        const evaluations = data.entities || [];
        allEvaluations = allEvaluations.concat(evaluations);
        
        nextUrl = data.nextUri ? `https://api.${config.REGION}${data.nextUri}` : null;
      }

      return allEvaluations;
    }

    async function fetchEvaluationsViaPOST(agentId, formIds) {
      const start = state.monthStart.toISOString();
      const end = state.monthEnd.toISOString();
      
      const body = {
        agentUserIds: [agentId],
        interval: `${start}/${end}`,
        expandAnswerTotalScores: true,
        pageSize: 50
      };

      if (formIds && formIds.length > 0) {
        body.formIds = formIds;
      }

      const url = `https://api.${config.REGION}/api/v2/quality/evaluations/query`;
      let allEvaluations = [];
      let pageNumber = 1;

      while (true) {
        body.pageNumber = pageNumber;
        
        const res = await rateLimitedFetch(url, {
          method: 'POST',
          body: JSON.stringify(body)
        });

        if (!res.ok) {
          throw new Error(`POST method failed: ${res.status}`);
        }

        const data = await res.json();
        const evaluations = data.entities || [];
        
        if (evaluations.length === 0) break;
        
        allEvaluations = allEvaluations.concat(evaluations);
        
        // Check if there are more pages
        if (!data.nextUri && evaluations.length < body.pageSize) {
          break;
        }
        
        pageNumber++;
      }

      return allEvaluations;
    }

    // ===== Form Details Lookup (robust: keys by id *and* contextId) =====
    function buildFormLookup(formDetails) {
      const questionLookup = new Map(); // q.id or q.contextId -> { text, isCritical, isFatal, groupId }
      const answerLookup   = new Map(); // `${qKey}|${a.id}` or `${qKey}|${a.contextId}` -> answerText
      const answerLookupAny = new Map(); // a.id or a.contextId -> answerText (unscoped fallback)
      const groupLookup    = new Map(); // group.id or group.contextId -> groupName
      
      if (!formDetails || !Array.isArray(formDetails.questionGroups)) {
        return { questionLookup, answerLookup, answerLookupAny, groupLookup };
      }

      function indexQuestion(q, groupId) {
        const payload = {
          text: q.text || `Question ${q.id || q.contextId}`,
          isCritical: !!q.isCritical,
          isFatal: !!q.isKill,
          groupId
        };
        if (q.id)        questionLookup.set(q.id, payload);
        if (q.contextId) questionLookup.set(q.contextId, payload);

        const qKeys = [q.id, q.contextId].filter(Boolean);
        (q.answerOptions || []).forEach(a => {
          const aText = a.text || `Answer ${a.id || a.contextId}`;
          qKeys.forEach(qKey => {
            if (a.id)        answerLookup.set(`${qKey}|${a.id}`, aText);
            if (a.contextId) answerLookup.set(`${qKey}|${a.contextId}`, aText);
          });
          if (a.id)        answerLookupAny.set(a.id, aText);
          if (a.contextId) answerLookupAny.set(a.contextId, aText);
        });
      }

      function walk(groups) {
        groups.forEach(g => {
          const gName = g.name || 'Unnamed Group';
          if (g.id)        groupLookup.set(g.id, gName);
          if (g.contextId) groupLookup.set(g.contextId, gName);

          (g.questions || []).forEach(q => indexQuestion(q, g.id || g.contextId));
          if (Array.isArray(g.questionGroups)) walk(g.questionGroups);
        });
      }

      walk(formDetails.questionGroups);
      return { questionLookup, answerLookup, answerLookupAny, groupLookup };
    }

    // Normalize selected answer IDs (single or multiple)
    function getSelectedAnswerIds(qScore){
      const arr =
        qScore.selectedAnswerIds ||
        qScore.selectedAnswerOptionIds ||
        qScore.selectedAnswerContextIds ||
        qScore.selectedAnswerOptionContextIds ||
        (qScore.selectedAnswerId ? [qScore.selectedAnswerId] : null) ||
        (qScore.answerOptionId ? [qScore.answerOptionId] : null) ||
        (qScore.answerId ? [qScore.answerId] : null) ||
        (qScore.answerContextId ? [qScore.answerContextId] : null) ||
        [];
      return Array.isArray(arr) ? arr : [];
    }

    function getAnswerTexts(ansIds, qKeyCandidates, answerLookup, answerLookupAny, qScore){
      const texts = [];
      for (const ansId of ansIds){
        let t = null;
        for (const qKey of qKeyCandidates){
          const key = `${qKey}|${ansId}`;
          if (answerLookup.has(key)) { t = answerLookup.get(key); break; }
        }
        if (!t && answerLookupAny.has(ansId)) t = answerLookupAny.get(ansId);
        if (!t && qScore && qScore.answer && qScore.answer.text) t = qScore.answer.text; // inline object sometimes present
        if (!t && Array.isArray(qScore?.selectedAnswers)){
          const found = qScore.selectedAnswers.find(x => x.id===ansId || x.contextId===ansId);
          if (found && found.text) t = found.text;
        }
        texts.push(t || `Answer ${ansId}`);
      }
      return texts;
    }

    // ===== Renderers =====
    function renderAll(){
      console.log('Rendering all views with', state.evals.length, 'evaluations');
      renderOverview();
      renderTrends();
      renderDetails();
      renderCritical();
    }

    function resolveUserName(userId){
      const user = state.users.find(u=>u.id===userId);
      return user ? user.name : userId || '(unknown)';
    }
    
    function resolveForm(formId){ 
      return state.formsById[formId]; 
    }

    function getEvalPercent(e){
      const percent = e.totalScore || e.totalPercent || safeGet(e,'scoring.totalPercent') || safeGet(e,'oTotalPercent') || safeGet(e, 'answers.totalScore');
      if (percent === null || percent === undefined) return null;
      if (percent <= 1) return percent * 100; // if 0..1 scale
      return percent;
    }

    // -------- Overview (KPIs + per-agent table) --------
    function renderOverview(){
      const evals = state.evals;
      console.log('Rendering overview with', evals.length, 'evaluations');
      
      const byAgent = new Map();
      evals.forEach(e=>{
        const a = safeGet(e,'agent.id') || e.agentUserId || e.userId || '(unknown)';
        const p = getEvalPercent(e);
        if (!byAgent.has(a)) byAgent.set(a, {count:0, sum:0});
        const obj = byAgent.get(a);
        obj.count++;
        if (p!==null && isFinite(p)) obj.sum += Number(p);
      });
      
      const agentRows = [];
      let totalCount=0; // eslint
      for (const [agentId, {count,sum}] of byAgent.entries()){
        const avg = count ? (sum / count) : null;
        agentRows.push({ agent: resolveUserName(agentId), count, avg });
        totalCount += count;
      }
      agentRows.sort((a,b)=>a.agent.localeCompare(b.agent));

      // KPIs
      const overallAvg = (agentRows.length && totalCount) ? (agentRows.reduce((s,r)=>s+(r.avg||0),0)/agentRows.length) : null;
      document.getElementById('overviewKPIs').innerHTML = `
        <div class="kpi">
          <div class="label">Month</div>
          <div class="value">${document.getElementById('monthInput').value}</div>
        </div>
        <div class="kpi">
          <div class="label">Evaluations</div>
          <div class="value">${evals.length}</div>
        </div>
        <div class="kpi">
          <div class="label">Agents</div>
          <div class="value">${agentRows.length}</div>
        </div>
        <div class="kpi">
          <div class="label">Average Score (Agent Avg)</div>
          <div class="value">${overallAvg===null?'-':pct(overallAvg,1)}</div>
        </div>
      `;

      // Per-agent table
      const tbl = document.getElementById('agentSummaryTable');
      if (agentRows.length === 0) {
        tbl.innerHTML = '<tr><td colspan="3" class="muted">No evaluation data available for the selected criteria.</td></tr>';
      } else {
        tbl.innerHTML = `
          <thead><tr>
            <th>Agent</th><th>Evaluations</th><th>Average Score</th>
          </tr></thead>
          <tbody>
            ${agentRows.map(r=>`<tr><td>${r.agent}</td><td>${r.count}</td><td>${r.avg===null?'-':pct(r.avg,1)}</td></tr>`).join('')}
          </tbody>
        `;
      }
    }

    // -------- Trends (daily avg per agent) --------
    function renderTrends(){
      const evals = state.evals;
      const agents = Array.from(new Set(evals.map(e=> safeGet(e,'agent.id') || e.agentUserId))).filter(Boolean);
      const days = []; // ISO day keys
      for (let d=new Date(state.monthStart); d<=state.monthEnd; d.setUTCDate(d.getUTCDate()+1)){
        days.push(new Date(d).toISOString().split('T')[0]);
      }
      // Map: agent -> day -> {sum, count}
      const map = new Map();
      evals.forEach(e=>{
        const aid = safeGet(e,'agent.id') || e.agentUserId || '(unknown)';
        const dayKey = dayKeyUTC(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const p = getEvalPercent(e);
        if(!map.has(aid)) map.set(aid, new Map());
        const dm = map.get(aid);
        if(!dm.has(dayKey)) dm.set(dayKey, {sum:0, count:0});
        if (p!==null && isFinite(p)) { const o=dm.get(dayKey); o.sum+=Number(p); o.count++; }
      });

      const header = `<thead><tr><th>Agent</th>${days.map(k=>`<th>${toUKDate(k)}</th>`).join('')}</tr></thead>`;
      const rows = agents.map(aid=>{
        const dm = map.get(aid) || new Map();
        const cells = days.map(k=>{
          const v = dm.get(k);
          if(!v || v.count===0) return '<td>-</td>';
          return `<td>${pct(v.sum / v.count,1)}</td>`;
        }).join('');
        return `<tr><td>${resolveUserName(aid)}</td>${cells}</tr>`;
      }).join('');
      document.getElementById('trendTable').innerHTML = header + `<tbody>${rows}</tbody>`;
    }

    // -------- Details (expand per evaluation; question-level) --------
    async function renderDetails(){
      const c = document.getElementById('detailsContainer');
      if (!state.evals.length){ 
        c.innerHTML = '<div class="muted">No evaluations loaded.</div>'; 
        return; 
      }
      
      // Create a loading message while we fetch form details
      c.innerHTML = '<div class="info-message">Loading evaluation details...</div>';
      
      // Process evaluations asynchronously to fetch form details
      const evaluationElements = await Promise.all(state.evals.map(async (e) => {
        const agent = resolveUserName(safeGet(e,'agent.id') || e.agentUserId);
        const evaluator = resolveUserName(safeGet(e,'evaluator.id') || e.evaluatorUserId);
        const formId = safeGet(e,'form.id') || e.formId;
        const form = resolveForm(formId);
        const formName = form?.name || '(Form)';
        const when = toUKDate(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const convo = e.conversationId || e.conversation?.id || '(n/a)';
        const score = getEvalPercent(e);
        const questionGroups = safeGet(e, 'answers.questionGroupScores') || [];

        // Get form details and build lookup maps
        const formDetails = await getFormDetails(formId);
        const { questionLookup, answerLookup, answerLookupAny, groupLookup } = buildFormLookup(formDetails);
        
        // Build question rows organized by question groups
        let qRows = '';
        
        // Create a map of questions by group for organization
        const questionsByGroup = new Map();
        
        // Organize all questions by their group
        questionGroups.forEach(group => {
          const questionScores = group.questionScores || [];
          questionScores.forEach(qScore => {
            const groupId = group.questionGroupId || group.questionGroupContextId || 'ungrouped';
            if (!questionsByGroup.has(groupId)) {
              questionsByGroup.set(groupId, []);
            }
            questionsByGroup.get(groupId).push(qScore);
          });
        });
        
        // Helper to resolve question/answer text and flags
        function renderQuestionRow(qScore){
          const qid = qScore.questionId || null;
          const qCtxId = qScore.questionContextId || null;
          const qKeyCandidates = [qid, qCtxId].filter(Boolean);

          // Find question data
          let questionData = null;
          for (const qKey of qKeyCandidates){
            if (questionLookup.has(qKey)) { questionData = questionLookup.get(qKey); break; }
          }
          const questionText = (qScore.question && qScore.question.text) ? qScore.question.text : (questionData ? questionData.text : `Question ${qid || qCtxId || ''}`);

          // Answer text (supports multi-select)
          let answerText = 'N/A';
          const ansIds = getSelectedAnswerIds(qScore);
          if (ansIds.length > 0) {
            const texts = getAnswerTexts(ansIds, qKeyCandidates, answerLookup, answerLookupAny, qScore); 
            answerText = texts.join(', ');
          }

          const ansScore = qScore.score ?? null;
          const isFat = !!(qScore.failedKillQuestion || (questionData && questionData.isFatal));
          const isCrit = !!(qScore.failedCriticalQuestion || (questionData && questionData.isCritical && ansScore === 0));

          let rowClass = '';
          if (isFat) rowClass = 'fatal-question';
          else if (isCrit) rowClass = 'critical-warning';

          let allComments = '';
          if (qScore.comments) {
            allComments += `<div class="comment-bubble"><strong>Evaluator Comments:</strong> ${qScore.comments}</div>`;
          }
          if (qScore.aiAnswer && qScore.aiAnswer.explanation) {
            allComments += `<div class="comment-bubble"><strong>AI Analysis:</strong> ${qScore.aiAnswer.explanation}</div>`;
          }

          return `<tr class="${rowClass}">
            <td>${questionText}</td>
            <td>${answerText}</td>
            <td>${ansScore === null ? '-' : fmt(ansScore, 1)}</td>
            <td>${isFat ? '<span class="badge badge-fatal">Fatal</span>' : isCrit ? '<span class="badge badge-critical">Critical</span>' : '<span class="badge badge-ok">OK</span>'}</td>
            <td>${allComments}</td>
          </tr>`;
        }

        // Process groups in order from form details
        if (formDetails && Array.isArray(formDetails.questionGroups)) {
          const queue = [...formDetails.questionGroups];
          while (queue.length){
            const group = queue.shift();
            const gId = group.id || group.contextId;
            const groupQuestions = questionsByGroup.get(gId) || [];
            if (groupQuestions.length > 0){
              qRows += `<tr class="question-group-header"><td colspan="5">${group.name || 'Question Group'}</td></tr>`;
              for (const qScore of groupQuestions){
                qRows += renderQuestionRow(qScore);
              }
            }
            if (Array.isArray(group.questionGroups)) queue.push(...group.questionGroups);
          }
        }
        
        // Handle any unmatched questions
        const unmatchedQuestions = [];
        questionsByGroup.forEach((questions, groupId) => {
          if (!groupLookup.has(groupId)) {
            unmatchedQuestions.push(...questions);
          }
        });
        
        if (unmatchedQuestions.length > 0) {
          qRows += `<tr class="question-group-header"><td colspan="5">Additional Questions</td></tr>`;
          for (const qScore of unmatchedQuestions) {
            qRows += renderQuestionRow(qScore);
          }
        }

        return `
          <details class="evaluation">
            <summary>${when} • <strong>${agent}</strong> — ${formName} &nbsp;&middot;&nbsp; Score: <strong>${score===null?'-':pct(score,1)}</strong> ${convo!=='(n/a)'?`&nbsp;&middot;&nbsp; Conversation: ${convo}`:''}</summary>
            <div class="table-container">
              <table>
                <thead><tr><th>Question</th><th>Answer</th><th>Score</th><th>Flags</th><th>Comments</th></tr></thead>
                <tbody>${qRows || `<tr><td colspan="5" class="muted">No question data available.</td></tr>`}</tbody>
              </table>
            </div>
          </details>
        `;
      }));
      
      c.innerHTML = evaluationElements.join('');
    }

    // ===== Critical / Fatal summary =====
    function renderCritical(){
      // Count per question (by form + question id/context + text)
      const counts = new Map(); // key -> {formName, qText, critical, fatal}
      
      state.evals.forEach(e => {
        const formId = safeGet(e,'form.id') || e.formId;
        const formName = resolveForm(formId)?.name || '(Form)';
        const questionGroups = safeGet(e, 'answers.questionGroupScores') || [];

        questionGroups.forEach(group => {
          const questionScores = group.questionScores || [];
          questionScores.forEach(qScore => {
            const qid = qScore.questionId || qScore.questionContextId || '(unknown)';

            // Try to get actual question text from form details
            let qText = `Question ${qid}`;
            const formDetails = state.formDetailsCache.get(formId);
            if (formDetails) {
              const { questionLookup } = buildFormLookup(formDetails);
              const qData = questionLookup.get(qScore.questionId) || questionLookup.get(qScore.questionContextId);
              if (qData && qData.text) qText = qData.text;
            }

            const key = `${formId}|${qid}|${qText}`;
            if (!counts.has(key)) {
              counts.set(key, {formName, qText, critical: 0, fatal: 0});
            }

            const ansScore = qScore.score ?? null;
            const qDataTmp = (state.formDetailsCache.get(formId) ? buildFormLookup(state.formDetailsCache.get(formId)).questionLookup.get(qid) : null);
            const isFatal = !!qScore.failedKillQuestion;
            const isCritical = !!(qScore.failedCriticalQuestion || (qDataTmp && qDataTmp.isCritical && ansScore === 0));

            const o = counts.get(key);
            if (isFatal) o.fatal++;
            else if (isCritical) o.critical++;
          });
        });
      });

      const rows = Array.from(counts.values())
        .filter(r => r.fatal > 0 || r.critical > 0)
        .sort((a,b) => (b.fatal + b.critical) - (a.fatal + a.critical))
        .map(r => `<tr>
          <td>${r.formName}</td>
          <td>${r.qText}</td>
          <td>${r.critical}</td>
          <td>${r.fatal}</td>
          <td>${r.critical + r.fatal}</td>
        </tr>`).join('');

      document.getElementById('criticalTable').innerHTML = `
        <thead><tr>
          <th>Form</th><th>Question</th><th>Critical</th><th>Fatal/Kill</th><th>Total</th>
        </tr></thead>
        <tbody>${rows || `<tr><td colspan="5" class="muted">No critical/fatal marks found for the selected period.</td></tr>`}</tbody>
      `;
    }

    // ===== Form details fetch (cached) =====
    async function getFormDetails(formId) {
      if (state.formDetailsCache.has(formId)) {
        return state.formDetailsCache.get(formId);
      }
      try {
        const url = `https://api.${config.REGION}/api/v2/quality/forms/evaluations/${formId}`;
        const res = await rateLimitedFetch(url);
        if (!res.ok) {
          console.warn(`Failed to fetch form details ${formId}: ${res.status}`);
          return null;
        }
        const formDetails = await res.json();
        state.formDetailsCache.set(formId, formDetails);
        return formDetails;
      } catch (error) {
        console.warn(`Error fetching form details for ${formId}:`, error);
        return null;
      }
    }
  </script>
</body>
</html>
