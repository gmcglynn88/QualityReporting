<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    /* ALL YOUR CSS STYLES REMAIN UNCHANGED */
    :root{ --primary-color:#63AB8F; --secondary-color:#4A8C7D; --border-color:#DEE2E6;
      --light-bg:#F8F9FA; --card-bg:#FFFFFF; --text-color:#2C3E50; --text-light:#6C757D; --pill:#e9f6f0;
      --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    body{font-family:'Aptos','Segoe UI',system-ui,-apple-system,Arial,sans-serif;margin:20px;padding:20px;max-width:1400px;background:var(--light-bg);color:var(--text-color)}
    #logo-container{text-align:center;margin-bottom:20px} #logo{width:300px}
    h1{margin:0 0 16px}
    .card{background:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:24px;margin-top:16px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    label{display:block;font-weight:600;margin-bottom:6px}
    input,select,button,textarea{padding:10px;border:1px solid var(--border-color);border-radius:6px;background:#fff;font-size:14px}
    button{background:var(--primary-color);color:#fff;font-weight:600;cursor:pointer;transition:background .2s}
    button:hover{background:var(--secondary-color)} button:disabled{background:var(--text-light);cursor:not-allowed}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;align-items:start}
    .full-width-btn{width:100%;padding:14px 18px;font-size:16px;margin-top:12px}
    .muted{color:var(--text-light);font-size:12px}
    .section-title{margin:0 0 10px;color:var(--secondary-color)}
    #messageContainer{display:none;margin-top:12px}
    .error-message{color:#b4231a;background:#fee2e2;border:1px solid #fecaca;padding:10px;border-radius:6px}
    .success-message{color:#14532d;background:#dcfce7;border:1px solid #bbf7d0;padding:10px;border-radius:6px}
    .info-message{color:#6b4e16;background:#fff7ed;border:1px solid #ffedd5;padding:10px;border-radius:6px}

    table{width:100%;border-collapse:collapse;margin-top:12px;border:1px solid var(--border-color);border-radius:6px;overflow:hidden}
    th,td{padding:10px 12px;text-align:left;border-bottom:1px solid var(--border-color);vertical-align:top}
    th{background-color:var(--primary-color);color:white;font-weight:600}
    tr:hover{background-color:rgba(99,171,143,.05)}
    .table-container{overflow-x:auto;border:1px solid var(--border-color);border-radius:6px;padding:1px;margin-top:10px}

    /* Frozen column styling for analytics table */
    .frozen-table-container { position: relative; overflow: auto; border: 1px solid var(--border-color); border-radius: 6px; margin-top: 10px; max-height: 600px; -webkit-overflow-scrolling: touch; }
    .frozen-table { border-collapse: separate; border-spacing: 0; width: max-content; min-width: 100%; }
    .frozen-table th, .frozen-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: top; white-space: nowrap; background: var(--card-bg); position: relative; }
    .frozen-table thead th { background-color: var(--primary-color); color: white; font-weight: 600; position: sticky; top: 0; z-index: 10; }
    .frozen-table th:first-child, .frozen-table td:first-child { position: sticky; left: 0; background: var(--card-bg); background-clip: padding-box; z-index: 12; border-right: 2px solid var(--border-color); min-width: 220px; }
    .frozen-table thead th:first-child { z-index: 20; background: var(--primary-color); }
    .frozen-table tr:hover td { background-color: rgba(99,171,143,.05); }
    .frozen-table tr:hover td:first-child { background: rgba(99,171,143,.1); }

    /* Tab styling - Updated to match your reference app but keep original structure */
    .main-tab-container {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .main-tab-button {
      padding: 10px 16px;
      background: #ffffff;
      border: 2px solid var(--primary-color);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      transition: background .2s, color .2s;
    }

    .main-tab-button:hover {
      background: var(--pill);
    }

    .main-tab-button.active {
      background: var(--primary-color);
      color: #ffffff;
    }

    .main-tab-content {
      display: none;
    }

    .main-tab-content.active {
      display: block;
    }

    /* Original tab styling for the nested tabs (unchanged) */
    .tab{display:inline-block;padding:12px 20px;margin-right:10px;background:#eee;cursor:pointer;border-radius:6px;font-weight:500}
    .tab.active{background:var(--primary-color);color:white}
    .tab-content{display:none}
    .tab-content.active{display:block}

    .badge{display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;border:1px solid var(--border-color);background:#fff}
    .badge-critical{color:#b4231a;border-color:#fecaca;background:#fee2e2}
    .badge-fatal{color:#fff;background:#b4231a;border-color:#b4231a}
    .badge-ok{color:#14532d;background:#dcfce7;border-color:#bbf7d0}
    details.evaluation{border:1px solid var(--border-color);border-radius:8px;padding:10px;margin:10px 0;background:#fff}
    details.evaluation summary{cursor:pointer;font-weight:600;padding:8px 0;}

    .kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;margin-top:10px}
    .kpi{background:#fff;border:1px solid var(--border-color);border-radius:8px;padding:12px}
    .kpi .label{color:var(--text-light);font-size:12px}
    .kpi .value{font-size:20px;font-weight:700;margin-top:4px}

    .critical-summary-kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-bottom:20px}
    .critical-kpi{background:#fff;border:2px solid var(--border-color);border-radius:12px;padding:20px;text-align:center}
    .critical-kpi.critical{border-color:#f59e0b}
    .critical-kpi.fatal{border-color:#ef4444}
    .critical-kpi .number{font-size:32px;font-weight:800;line-height:1}
    .critical-kpi.critical .number{color:#f59e0b}
    .critical-kpi.fatal .number{color:#ef4444}
    .critical-kpi .label{color:var(--text-light);margin-top:8px;font-size:14px;font-weight:600}

    .checkbox-dropdown{position:relative;min-width:220px;width:100%}
    .cd-trigger{display:flex;align-items:center;justify-content:space-between;border:1px solid var(--border-color);border-radius:6px;background:#fff;padding:10px;cursor:pointer;width:100%;box-sizing:border-box}
    .cd-trigger .label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1}
    .cd-trigger .count{background:var(--pill);border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;color:#2c3e50;flex-shrink:0;margin-left:8px}
    .cd-panel{position:absolute;z-index:1000;margin-top:6px;background:#fff;border:1px solid var(--border-color);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.12);width:100%;max-height:340px;overflow:hidden;display:none;box-sizing:border-box}
    .cd-panel.open{display:block}
    .cd-header{padding:10px;border-bottom:1px solid var(--border-color);display:flex;gap:8px;align-items:center}
    .cd-search{flex:1;border:1px solid var(--border-color);border-radius:6px;padding:8px;width:100%;box-sizing:border-box}
    .cd-actions{display:flex;gap:8px}
    .cd-actions button{background:#eef6f2;color:#2c3e50;border:1px solid var(--border-color);border-radius:6px;padding:8px 10px;cursor:pointer;white-space:nowrap}
    .cd-selectall{padding:8px 12px;border-bottom:1px solid var(--border-color);display:flex;align-items:center;gap:10px}
    .cd-list{max-height:260px;overflow:auto}
    .cd-item{display:flex;align-items:center;gap:10px;padding:8px 12px;border-bottom:1px solid #f1f3f5}
    .cd-item label{display:flex;align-items:center;gap:10px;cursor:pointer;width:100%}
    .cd-footer{padding:8px 12px;background:#fafafa;border-top:1px solid var(--border-color);font-size:12px;color:#6c757d;display:flex;justify-content:space-between}

    .loading-spinner{display:inline-block;width:20px;height:20px;border:2px solid #f3f3f3;border-top:2px solid var(--primary-color);border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}

    .comment-bubble{background:#f8f9fa;border:1px solid #dee2e6;border-radius:12px;padding:8px 12px;margin-top:4px;font-size:12px;color:#6c757d}

    tr.critical-warning{background-color:#fffbeb!important;border-left:4px solid #f59e0b}
    tr.fatal-question{background-color:#fef2f2!important;border-left:4px solid #dc2626}
    tr.critical-warning:hover{background-color:#fef3c7!important}
    tr.fatal-question:hover{background-color:#fecaca!important}

    .details-table th:nth-child(1),
    .details-table td:nth-child(1){ width:15%; min-width:160px }
    .details-table th:nth-child(2),
    .details-table td:nth-child(2){ width:15% }
    .details-table th:nth-child(3),
    .details-table td:nth-child(3){ width:20% }
    .details-table th:nth-child(4),
    .details-table td:nth-child(4){ width:10%; white-space:nowrap }
    .details-table th:nth-child(5),
    .details-table td:nth-child(5){ width:20% }
    .details-table th:nth-child(6),
    .details-table td:nth-child(6){ width:20%; text-align:center }

    .trend-table th:first-child,
    .trend-table td:first-child{ width:220px; min-width:220px; white-space:nowrap }

    .insight-row{display:flex;align-items:center;gap:10px;padding:8px;border-bottom:1px solid #f1f3f5}
    .insight-name{width:200px;flex-shrink:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .insight-bar-wrap{flex:1;background:#f1f3f5;border-radius:999px;overflow:hidden;height:12px}
    .insight-bar{height:100%;background:var(--primary-color)}
    .insight-meta{width:120px;text-align:right;font-size:12px;color:#6c757d}
    .pill{display:inline-block;border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;background:#fff;margin-left:6px}

    .chart-row{display:flex;align-items:center;gap:10px;margin:8px 0}
    .chart-label{width:200px;flex-shrink:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .chart-svg{flex:1;border:1px solid #f1f3f5;border-radius:8px;background:#fafafa}
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .legend .key{display:flex;align-items:center;gap:6px}
    .swatch{width:14px;height:14px;border-radius:3px;border:1px solid #ddd}

    .sortable th{cursor:pointer}
    .sortable th .sort-ind{margin-left:6px;opacity:.8;font-weight:700}

    .stacked-bar-container { position: relative; height: 400px; margin: 20px 0; }
    
    /* New styles for enhancements */
    .time-period-selector { margin: 16px 0; }
    .time-period-selector label { display: inline-block; margin-right: 10px; }
    .agent-failure-table { margin-top: 20px; }
    .agent-failure-table th { background-color: var(--warn); }
    .agent-failure-table tr.fatal-agent th { background-color: var(--bad); }
    .agent-failure-table td { vertical-align: top; }
    .failure-details { font-size: 12px; color: var(--text-light); }
    .failure-dates { margin-top: 4px; font-size: 11px; }
    .sort-header { cursor: pointer; user-select: none; }
    .sort-header:hover { background-color: rgba(255,255,255,0.2); }
    .sort-arrow { margin-left: 5px; }
    .contact-info { font-size: 12px; color: var(--text-light); margin-top: 2px; }
    
    /* New styles for trends tab */
    .trend-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .trend-chart-container { height: 500px; margin: 20px 0; }
    .trend-table-container { margin-top: 30px; }
    .trend-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin: 20px 0; }
    .trend-stat { background: #fff; border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; text-align: center; }
    .trend-stat .value { font-size: 24px; font-weight: bold; margin: 5px 0; }
    .trend-stat .label { font-size: 12px; color: var(--text-light); }
    .trend-stat.good .value { color: var(--ok); }
    .trend-stat.warning .value { color: var(--warn); }
    .trend-stat.bad .value { color: var(--bad); }
    
    /* Filter controls for details tab */
    .details-filters { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .details-filters .filter-group { display: flex; flex-direction: column; }
    .details-filters label { margin-bottom: 8px; }
    
    /* Expandable rows styling */
    .expandable-row { cursor: pointer; }
    .expandable-content { display: none; padding: 20px; background: var(--light-bg); border-top: 1px solid var(--border-color); }
    .expandable-content.expanded { display: table-row; }
    .question-details-table { width: 100%; margin-top: 10px; }
    .question-details-table th { background-color: var(--secondary-color); }
    .expand-icon { margin-right: 8px; transition: transform 0.3s; }
    .expanded .expand-icon { transform: rotate(90deg); }
    
    /* Analytics specific styles */
    .analytics-chart-container { height: 400px; margin: 20px 0; }
    
    /* How to Use tab specific styles */
    .guide-step { margin: 20px 0; padding-left: 20px; border-left: 3px solid var(--primary-color); }
    .guide-step h3 { margin-top: 0; color: var(--secondary-color); }
    .guide-step p { margin: 8px 0; }
    .guide-note { background: var(--pill); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; margin: 12px 0; }
    
    /* Month Comparison Styles */
    .month-comparison { 
      background: var(--light-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      margin: 20px 0;
    }
    .month-comparison h3 { 
      margin: 0 0 16px 0;
      color: var(--secondary-color);
      font-size: 18px;
    }
    .comparison-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    .comparison-item {
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 12px;
      text-align: center;
    }
    .comparison-item .label {
      font-size: 12px;
      color: var(--text-light);
      margin-bottom: 4px;
    }
    .comparison-item .value {
      font-size: 20px;
      font-weight: bold;
      margin: 4px 0;
    }
    .comparison-item .change {
      font-size: 12px;
      font-weight: 500;
    }
    .comparison-item .change.positive {
      color: var(--ok);
    }
    .comparison-item .change.negative {
      color: var(--bad);
    }
    .comparison-item .change.neutral {
      color: var(--text-light);
    }
    .comparison-note {
      font-size: 11px;
      color: var(--text-light);
      margin-top: 8px;
      text-align: center;
    }

    /* NEW STYLES: Date Range Selector Styles (from the first code) */
    .date-range-container {
      width: 100%;
    }
    
    .date-range-input {
      width: 100%;
      padding: 10px 12px;
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 14px;
      color: var(--text-color);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s ease;
      min-height: 42px;
      box-sizing: border-box;
    }
    
    .date-range-input:hover {
      border-color: var(--primary-color);
      background-color: var(--pill);
    }
    
    .calendar-icon {
      color: var(--text-light);
      font-size: 16px;
      flex-shrink: 0;
    }
    
    #date-range-value {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
      margin-right: 8px;
    }
    
    .calendar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
    }
    
    .calendar-overlay.active {
      display: flex;
    }
    
    .calendar-popup {
      width: 100%;
      max-width: 340px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
      overflow: hidden;
      animation: fadeIn 0.2s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .presets-sidebar {
      padding: 20px;
      background: var(--light-bg);
      border-bottom: 1px solid var(--border-color);
    }
    
    .presets-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-light);
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    
    .preset-btn {
      padding: 10px 12px;
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-size: 14px;
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }
    
    .preset-btn:hover {
      background: var(--pill);
      border-color: var(--primary-color);
    }
    
    .preset-btn.active {
      background: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
      font-weight: 600;
    }
    
    .calendar-container {
      padding: 20px;
    }
    
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .current-month {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-color);
    }
    
    .month-navigation {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .nav-btn {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-color);
      font-weight: 600;
      transition: all 0.2s ease;
    }
    
    .nav-btn:hover {
      background: var(--pill);
      border-color: var(--primary-color);
    }
    
    .today-btn {
      padding: 8px 12px;
      background: var(--pill);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-weight: 600;
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
    }
    
    .today-btn:hover {
      background: #e0f0ea;
    }
    
    .weekdays-header {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      margin-bottom: 12px;
      text-align: center;
    }
    
    .weekday {
      font-weight: 600;
      color: var(--text-light);
      font-size: 12px;
      padding: 6px 0;
      text-transform: uppercase;
    }
    
    .calendar-days {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 6px;
    }
    
    .calendar-day {
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: var(--text-color);
      font-weight: 500;
    }
    
    .calendar-day:hover {
      background: var(--pill);
    }
    
    .calendar-day.other-month {
      color: #cbd5e1;
    }
    
    .calendar-day.today {
      border: 2px solid var(--primary-color);
      color: var(--primary-color);
    }
    
    .calendar-day.in-range {
      background: #e0f0ea;
      color: var(--secondary-color);
    }
    
    .calendar-day.range-start {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      font-weight: 600;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
    
    .calendar-day.range-end {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      font-weight: 600;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
    
    .range-summary {
      padding: 16px 20px;
      background: var(--light-bg);
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .range-info {
      font-size: 14px;
      color: var(--text-color);
    }
    
    .range-dates {
      color: var(--primary-color);
      font-weight: 600;
      margin-left: 8px;
    }
    
    .calendar-actions {
      display: flex;
      gap: 10px;
    }
    
    .btn-secondary {
      padding: 10px 16px;
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-weight: 600;
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
    }
    
    .btn-secondary:hover {
      background: var(--pill);
    }
    
    .btn-primary {
      padding: 10px 20px;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn-primary:hover {
      background: var(--secondary-color);
    }
    
    .btn-primary:disabled {
      background: var(--text-light);
      cursor: not-allowed;
    }
    
    /* Chart placeholder styling */
    .chart-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(248, 249, 250, 0.9);
      z-index: 5;
      text-align: center;
      padding: 20px;
    }
    
    /* Progress bar for loading */
    .progress-bar{width:100%;height:8px;background:var(--border-color);border-radius:4px;overflow:hidden;margin:10px 0}
    .progress-fill{height:100%;background:var(--primary-color);transition:width .3s}
    
    /* Loading section */
    #progressSection { display: none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div id="authCard" class="card" style="display:block;">
    <div id="auth-message" class="info-message">Authenticating with PureCloud...</div>
  </div>

  <div id="appContent" style="display:none;">
    <div id="messageContainer"></div>

    <!-- Main Tab Navigation - Quality Reporting vs How to Use -->
    <div class="main-tab-container">
      <button class="main-tab-button active" data-tab="tab-quality">Quality Reporting</button>
      <button class="main-tab-button" data-tab="tab-guide">How to Use</button>
    </div>

    <!-- Quality Reporting Tab (Original App) -->
    <div id="tab-quality" class="main-tab-content active">
      <div class="card">
        <h2 class="section-title">Configuration</h2>
        <div class="controls">
          <div>
            <label for="userDropdown">Agents</label>
            <div id="userDropdown" class="checkbox-dropdown"></div>
          </div>
          <div>
            <label for="teamDropdown">Work Teams</label>
            <div id="teamDropdown" class="checkbox-dropdown"></div>
          </div>
          <div>
            <label for="formDropdown">Evaluation Forms</label>
            <div id="formDropdown" class="checkbox-dropdown"></div>
          </div>
          <div>
            <label>Date Range</label>
            <div class="date-range-container">
              <div class="date-range-input" id="date-range-input">
                <span id="date-range-value">Select date range</span>
                <span class="calendar-icon">ðŸ“…</span>
              </div>
            </div>
            <input type="hidden" id="fromDate">
            <input type="hidden" id="toDate">
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="loadBtn" class="full-width-btn" disabled>
              <span class="loading-spinner" style="display:none"></span>
              <span class="btn-text">Load Evaluations</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Progress Section -->
      <div id="progressSection" style="display:none;">
        <div class="card">
          <h3 style="margin:0 0 8px;">Fetching Evaluations</h3>
          <div class="muted" id="chunkInfo">Processing date range...</div>
          <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
          <div style="display:flex;justify-content:space-between;font-size:14px" class="muted">
            <span id="progressText">0%</span><span id="chunkText">Processing...</span>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="margin-bottom:10px;">
          <!-- ORIGINAL TABS - UNCHANGED -->
          <div id="tabs">
            <div id="overviewTabButton" class="tab active">Overview</div>
            <div id="analyticsTabButton" class="tab">Analytics</div>
            <div id="trendsTabButton" class="tab">Trends</div>
            <div id="detailsTabButton" class="tab">Evaluation Details</div>
            <div id="criticalTabButton" class="tab">Critical / Fatal Summary</div>
          </div>
        </div>

        <div id="overviewTab" class="tab-content active">
          <h2 class="section-title">Monthly Overview</h2>
          <div id="overviewKPIs" class="kpis"></div>
          <div class="table-container">
            <table id="agentSummaryTable"></table>
          </div>
        </div>

        <div id="analyticsTab" class="tab-content">
          <h2 class="section-title">Analytics</h2>

          <!-- Month Comparison Section - NEW -->
          <div id="monthComparison" class="month-comparison" style="display:none;">
            <h3>Month-to-Month Comparison</h3>
            <div class="comparison-grid" id="comparisonGrid">
              <!-- Will be populated by JavaScript -->
            </div>
            <div class="comparison-note">Comparing two most recent months with data</div>
          </div>

          <div class="controls" style="margin-top:8px">
            <div>
              <label for="anaFrom">From (Month)</label>
              <input id="anaFrom" type="month">
            </div>
            <div>
              <label for="anaTo">To (Month)</label>
              <input id="anaTo" type="month">
            </div>
            <div>
              <label for="analyticsTeamDropdown">Filter by Work Team</label>
              <div id="analyticsTeamDropdown" class="checkbox-dropdown"></div>
            </div>
          </div>

          <div class="controls" style="margin-top:8px">
            <div>
              <label for="passTarget">Pass target (%)</label>
              <input id="passTarget" type="number" min="0" max="100" value="85">
            </div>
            <div>
              <label for="amberBand">Amber band (Â±%)</label>
              <input id="amberBand" type="number" min="0" max="20" value="5">
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="loadAnalyticsBtn" class="full-width-btn">
                <span class="loading-spinner" style="display:none"></span>
                <span class="btn-text">Load Range</span>
              </button>
            </div>
          </div>

          <div id="analyticsKPIs" class="kpis"></div>

          <!-- Updated Analytics Visualizations -->
          <div class="card" style="padding:16px;margin-top:10px">
            <h3 class="section-title" style="margin:0 0 8px">Performance Distribution by Media Type</h3>
            <div class="analytics-chart-container">
              <canvas id="mediaTypeChart"></canvas>
            </div>
            <div class="legend">
              <div class="key"><span class="swatch" style="background:var(--ok)"></span>Pass (â‰¥85%)</div>
              <div class="key"><span class="swatch" style="background:var(--warn)"></span>Amber (80-84%)</div>
              <div class="key"><span class="swatch" style="background:var(--bad)"></span>Fail (<80%)</div>
            </div>
          </div>

          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(400px,1fr));gap:16px;margin-top:16px">
            <div class="card">
              <h3 class="section-title" style="margin:0 0 8px">Agent Performance Trends</h3>
              <div style="height:300px">
                <canvas id="agentTrendChart"></canvas>
              </div>
            </div>
            <div class="card">
              <h3 class="section-title" style="margin:0 0 8px">Score Distribution</h3>
              <div style="height:300px">
                <canvas id="scoreDistributionChart"></canvas>
              </div>
            </div>
          </div>

          <!-- Fixed frozen table container for media table -->
          <div class="frozen-table-container">
            <table id="mediaTable" class="frozen-table sortable"></table>
          </div>
          <div class="table-container">
            <table id="repeatFailsTable" class="sortable"></table>
          </div>

          <div class="card" style="padding:16px;margin-top:16px">
            <div style="display:flex;align-items:center;gap:10px;justify-content:space-between">
              <h3 class="section-title" style="margin:0">Agent Insights</h3>
              <div>
                <label class="muted" style="margin-right:6px">Sort by:</label>
                <select id="insightsSort">
                  <option value="avgDesc">Avg score (highâ†’low)</option>
                  <option value="avgAsc">Avg score (lowâ†’high)</option>
                  <option value="failsDesc">Fails (highâ†’low)</option>
                  <option value="evalsDesc">Evals (highâ†’low)</option>
                </select>
              </div>
            </div>
            <div id="agentInsights" style="margin-top:8px"></div>
          </div>

          <h3 class="section-title" style="margin-top:18px">Daily Trend by Agent (Selected Period)</h3>
          <div id="trendTable" class="frozen-table-container"></div>

          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-top:16px">
            <div class="table-container">
              <table id="topAgentsTable"></table>
            </div>
            <div class="table-container">
              <table id="bottomAgentsTable"></table>
            </div>
          </div>
        </div>

        <div id="trendsTab" class="tab-content">
          <h2 class="section-title">Performance Trends</h2>
          
          <div class="controls" style="margin-top:8px">
            <div>
              <label for="trendFrom">From (Month)</label>
              <input id="trendFrom" type="month">
            </div>
            <div>
              <label for="trendTo">To (Month)</label>
              <input id="trendTo" type="month">
            </div>
            <div>
              <label for="trendTeamDropdown">Filter by Work Team</label>
              <div id="trendTeamDropdown" class="checkbox-dropdown"></div>
            </div>
          </div>

          <div class="controls" style="margin-top:8px">
            <div>
              <label for="trendPassTarget">Pass target (%)</label>
              <input id="trendPassTarget" type="number" min="0" max="100" value="85">
            </div>
            <div>
              <label for="trendAmberBand">Amber band (Â±%)</label>
              <input id="trendAmberBand" type="number" min="0" max="20" value="5">
            </div>
            <div>
              <label for="trendPeriodSelect">Time Period View</label>
              <select id="trendPeriodSelect" class="full-width-btn">
                <option value="month">Month over Month</option>
                <option value="week">Week over Week</option>
              </select>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="loadTrendsBtn" class="full-width-btn">
                <span class="loading-spinner" style="display:none"></span>
                <span class="btn-text">Load Trends</span>
              </button>
            </div>
          </div>

          <div id="trendsKPIs" class="kpis"></div>

          <!-- Month over Month / Week over Week View -->
          <div id="trendsView" style="display:none;">
            <div class="card" style="padding:16px;margin-top:10px;">
              <h3 class="section-title" style="margin:0 0 8px" id="trendsTitle">Month over Month Performance</h3>
              <div class="trend-chart-container">
                <canvas id="trendsChart"></canvas>
              </div>
              <div class="legend">
                <div class="key"><span class="swatch" style="background:var(--ok)"></span>Passed</div>
                <div class="key"><span class="swatch" style="background:var(--warn)"></span>Amber</div>
                <div class="key"><span class="swatch" style="background:var(--bad)"></span>Failed</div>
              </div>
            </div>

            <!-- Trend Statistics -->
            <div class="trend-stats" id="trendStats"></div>

            <!-- Trend Improvement Table -->
            <div class="trend-table-container">
              <h3 class="section-title">Agent Performance Trends</h3>
              <div class="frozen-table-container">
                <table id="trendImprovementTable" class="frozen-table sortable"></table>
              </div>
            </div>
          </div>

          <div id="trendsNoData" class="info-message" style="margin-top:20px;display:none;">
            No trend data available. Please load data for the selected period.
          </div>
        </div>

        <div id="detailsTab" class="tab-content">
          <h2 class="section-title">Evaluation Details (with Question Scores)</h2>
          
          <!-- Filter Controls -->
          <div class="details-filters">
            <div class="filter-group">
              <label for="detailsAgentFilter">Filter by Agent</label>
              <select id="detailsAgentFilter" class="full-width-btn">
                <option value="all">All Agents</option>
              </select>
            </div>
            <div class="filter-group">
              <label for="detailsScoreFilter">Filter by Score</label>
              <select id="detailsScoreFilter" class="full-width-btn">
                <option value="all">All Scores</option>
                <option value="pass">Pass (â‰¥85%)</option>
                <option value="amber">Amber (80-84%)</option>
                <option value="fail">Fail (<80%)</option>
                <option value="critical">With Critical Marks</option>
                <option value="fatal">With Fatal Marks</option>
              </select>
            </div>
            <div class="filter-group">
              <label>&nbsp;</label>
              <button id="applyFiltersBtn" class="full-width-btn">Apply Filters</button>
            </div>
          </div>
          
          <!-- Fixed frozen table container for details -->
          <div id="detailsContainer" class="frozen-table-container"></div>
        </div>

        <div id="criticalTab" class="tab-content">
          <h2 class="section-title">Critical / Fail Question Counts</h2>
          <div id="criticalSummaryKPIs" class="critical-summary-kpis"></div>
          
          <!-- New Agent Failure Table -->
          <div class="card" style="margin-top:20px;">
            <h3 class="section-title">Agent Mark Downs by Question</h3>
            <div id="agentFailuresContainer"></div>
          </div>
          
          <div class="table-container">
            <table id="criticalTable"></table>
          </div>
        </div>
      </div>
    </div> <!-- end tab-quality -->

    <!-- How to Use Tab -->
    <div id="tab-guide" class="main-tab-content">
      <div class="card">
        <h2 class="section-title">How to Use the Quality Reporting Tool</h2>
        
        <div class="guide-step">
          <h3>1. Initial Setup</h3>
          <p><strong>Authentication:</strong> The app automatically authenticates with Genesys Cloud using OAuth. You'll be redirected to login if needed.</p>
          <p><strong>Loading Data:</strong> Once authenticated, the app loads available agents, teams, and evaluation forms.</p>
        </div>

        <div class="guide-step">
          <h3>2. Configuration Panel</h3>
          <p><strong>Agents:</strong> Select individual agents you want to analyze. Use the search box to find specific agents.</p>
          <p><strong>Work Teams:</strong> Select entire teams to include all agents within those teams.</p>
          <p><strong>Evaluation Forms:</strong> Choose specific evaluation forms to filter results.</p>
          <p><strong>Date Range Selection:</strong> Use the new date range picker to select custom date ranges or use preset ranges (Today, Yesterday, This Week, Last Week).</p>
          <p><strong>Load Evaluations:</strong> Click this button after making your selections to load the data.</p>
          <div class="guide-note">
            <strong>Note:</strong> You must select at least one agent, team, or form before loading evaluations.
          </div>
        </div>

        <div class="guide-step">
          <h3>3. Overview Tab</h3>
          <p><strong>KPIs:</strong> View key metrics including total evaluations, number of agents, and average scores.</p>
          <p><strong>Agent Summary Table:</strong> See each agent's evaluation count and average score for the selected period.</p>
        </div>

        <div class="guide-step">
          <h3>4. Analytics Tab</h3>
          <p><strong>Date Range:</strong> Select a custom date range for deeper analysis.</p>
          <p><strong>Team Filtering:</strong> Filter analytics by specific work teams.</p>
          <p><strong>Pass Target Settings:</strong> Adjust the pass threshold (default 85%) and amber band (Â±5%).</p>
          <p><strong>Visualizations:</strong>
            <ul>
              <li><strong>Media Type Chart:</strong> Shows performance distribution across different media types</li>
              <li><strong>Agent Trends:</strong> Line chart showing score trends for top agents</li>
              <li><strong>Score Distribution:</strong> Histogram showing how scores are distributed</li>
            </ul>
          </p>
          <p><strong>Media Table:</strong> Detailed breakdown of agent performance by media type.</p>
          <p><strong>Repeat Failures:</strong> Identifies questions that frequently receive critical/fatal marks.</p>
          <p><strong>Agent Insights:</strong> Sortable list of agents with their performance metrics.</p>
          <p><strong>Daily Trends:</strong> Frozen table showing daily performance for each agent.</p>
          <p><strong>Top/Bottom Agents:</strong> Leaderboards showing best and worst performers.</p>
        </div>

        <div class="guide-step">
          <h3>5. Trends Tab</h3>
          <p><strong>Time Period Analysis:</strong> Compare performance month-over-month or week-over-week.</p>
          <p><strong>Trend Chart:</strong> Visual representation of pass/amber/fail trends over time.</p>
          <p><strong>Trend Statistics:</strong> Key metrics showing improvement or decline over the selected period.</p>
          <p><strong>Agent Improvement Table:</strong> Shows which agents improved or declined over time.</p>
        </div>

        <div class="guide-step">
          <h3>6. Evaluation Details Tab</h3>
          <p><strong>Filtering:</strong> Filter evaluations by agent and score range.</p>
          <p><strong>Sorting:</strong> Click column headers to sort by date, agent, form, or score.</p>
          <p><strong>Expandable Rows:</strong> Click any evaluation row to see detailed question scores, comments, and critical/fatal flags.</p>
          <p><strong>Contact Info:</strong> View customer contact information extracted from each evaluation.</p>
        </div>

        <div class="guide-step">
          <h3>7. Critical / Fatal Summary Tab</h3>
          <p><strong>Summary KPIs:</strong> Quick view of total critical and fatal marks.</p>
          <p><strong>Agent Failure Analysis:</strong> Detailed breakdown showing which agents received which critical/fatal marks and when.</p>
          <p><strong>Question Analysis:</strong> Identifies which questions most frequently receive critical/fatal marks across all agents.</p>
        </div>

        <div class="guide-step">
          <h3>8. Tips & Best Practices</h3>
          <div class="guide-note">
            <strong>Data Loading:</strong> Loading large date ranges or many agents may take a moment. Be patient during initial load.
          </div>
          <div class="guide-note">
            <strong>Critical vs Fatal:</strong> Fatal marks automatically fail the entire evaluation. Critical marks indicate serious issues but don't necessarily fail the evaluation.
          </div>
          <div class="guide-note">
            <strong>Exporting Data:</strong> Use your browser's print function (Ctrl+P) to export tables and charts as PDFs.
          </div>
          <div class="guide-note">
            <strong>Session Management:</strong> Your authentication token lasts for several hours. If you get logged out, simply refresh the page.
          </div>
        </div>

        <div class="guide-step">
          <h3>9. Troubleshooting</h3>
          <p><strong>No Data Loaded:</strong> Ensure you've selected at least one agent, team, or form and clicked "Load Evaluations".</p>
          <p><strong>Authentication Errors:</strong> Refresh the page to restart the OAuth flow.</p>
          <p><strong>Missing Form Details:</strong> Some evaluation forms may not load completely. This is normal for older or deleted forms.</p>
          <p><strong>Performance Issues:</strong> For very large datasets, try narrowing your date range or filtering by specific teams.</p>
        </div>

        <div class="guide-note" style="margin-top: 20px;">
          <strong>Please Note:</strong> This tool extracts and analyzes quality evaluation data from Genesys Cloud. All data is read-only and doesn't modify any evaluations in the system.
        </div>
      </div>
    </div> <!-- end tab-guide -->
  </div>

  <!-- Calendar Overlay (from the first code) -->
  <div class="calendar-overlay" id="calendar-overlay">
    <div class="calendar-popup" id="calendar-popup">
      <div class="presets-sidebar">
        <div class="presets-title">Quick Presets</div>
        <div class="preset-grid">
          <button class="preset-btn" data-preset="today">Today</button>
          <button class="preset-btn" data-preset="yesterday">Yesterday</button>
          <button class="preset-btn" data-preset="thisWeek">This week</button>
          <button class="preset-btn" data-preset="lastWeek">Last week</button>
          <button class="preset-btn active" data-preset="custom">Custom Range</button>
        </div>
      </div>
      
      <div class="calendar-container">
        <div class="calendar-header">
          <div class="current-month" id="current-month">Loading...</div>
          <div class="month-navigation">
            <button class="nav-btn" id="prev-month">&lt;</button>
            <button class="today-btn" id="today-btn">Today</button>
            <button class="nav-btn" id="next-month">&gt;</button>
          </div>
        </div>
        
        <div class="weekdays-header">
          <div class="weekday">Sun</div>
          <div class="weekday">Mon</div>
          <div class="weekday">Tue</div>
          <div class="weekday">Wed</div>
          <div class="weekday">Thu</div>
          <div class="weekday">Fri</div>
          <div class="weekday">Sat</div>
        </div>
        
        <div class="calendar-days" id="calendar-days">
          <!-- Calendar days will be generated by JavaScript -->
        </div>
      </div>
      
      <div class="range-summary">
        <div class="range-info">
          Selected: <span class="range-dates" id="selected-range">Select a date range</span>
        </div>
        <div class="calendar-actions">
          <button class="btn-secondary" id="clear-btn">Clear</button>
          <button class="btn-primary" id="apply-calendar-btn">Apply</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Global Functions for HTML onclick attributes =====
    window.toggleRow = function(index) {
      const row = document.getElementById(`details-row-${index}`);
      const icon = document.querySelector(`#details-row-${index}`).previousElementSibling.querySelector('.expand-icon');
      
      if (row.style.display === 'none') {
        row.style.display = 'table-row';
        icon.textContent = 'â–¼';
        icon.classList.add('expanded');
      } else {
        row.style.display = 'none';
        icon.textContent = 'â–¶';
        icon.classList.remove('expanded');
      }
    };

    window.sortDetails = function(field) {
      if (state.detailsSortField === field) {
        state.detailsSortDirection = state.detailsSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        state.detailsSortField = field;
        state.detailsSortDirection = 'desc';
      }
      renderDetails();
    };

    // ===== OAuth Configuration =====
    const clientId = 'fe305808-b368-4547-8af9-325d28d552bb';
    const config = { REGION: 'mypurecloud.ie' };
    const redirectUri = 'https://gmcglynn88.github.io/QualityReporting/'; // must exactly match your OAuth app
    // Hard-coded, pre-encoded OAuth URL
    const oauthUrl = 'https://login.mypurecloud.ie/oauth/authorize?client_id=fe305808-b368-4547-8af9-325d28d552bb&response_type=token&redirect_uri=https%3A%2F%2Fgmcglynn88.github.io%2FQualityReporting%2F&state=qa';

    const state = {
      accessToken: null,
      users: [],
      forms: [],
      formsById: {},
      teams: [],
      teamsById: {},
      teamMembers: new Map(),

      evals: [],
      monthStart: null,
      monthEnd: null,

      analyticsEvals: null,
      analyticsRange: null,
      
      trendsEvals: null,
      trendsRange: null,

      formDetailsCache: new Map(),
      formLookupCache: new Map(),
      combinedLookupCache: new Map(),
      
      // New state for sorting and filtering
      detailsSortField: 'date',
      detailsSortDirection: 'desc',
      detailsAgentFilter: 'all',
      detailsScoreFilter: 'all',
      filteredEvals: [],
      
      // Date range state
      dateRangeState: {
        currentDate: new Date(),
        startDate: null,
        endDate: null,
        isSelectingRange: false
      }
    };

    const dropdowns = { 
      users: null, 
      teams: null, 
      forms: null, 
      analyticsTeams: null,
      trendTeams: null 
    };

    // Chart colours resolved from CSS vars (Chart.js can't read CSS vars directly)
    const cssVar = k => getComputedStyle(document.documentElement).getPropertyValue(k).trim();
    let COLORS = { OK: '#22c55e', WARN: '#f59e0b', BAD: '#ef4444', TEXT: '#2C3E50', BLUE: '#3b82f6', PRIMARY: '#63AB8F', SECONDARY: '#4A8C7D' };
    function resolveColors() {
      COLORS.OK   = cssVar('--ok')          || COLORS.OK;
      COLORS.WARN = cssVar('--warn')        || COLORS.WARN;
      COLORS.BAD  = cssVar('--bad')         || COLORS.BAD;
      COLORS.TEXT = cssVar('--text-color')  || COLORS.TEXT;
      COLORS.PRIMARY = cssVar('--primary-color') || COLORS.PRIMARY;
      COLORS.SECONDARY = cssVar('--secondary-color') || COLORS.SECONDARY;
    }

    // Throttle + backoff
    let lastApiCall = 0;
    const API_DELAY = 120;                  // ms spacing between calls
    const MAX_CONCURRENT_AGENT_BATCH = 3;

    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    function msg(html,type='info'){
      const box=document.getElementById('messageContainer');
      box.innerHTML=`<div class="${type}-message">${html}</div>`;
      box.style.display='block';
      if(type==='success'){ setTimeout(()=>box.style.display='none',5000); }
    }

    function setLoading(button,isLoading){
      const spinner=button.querySelector('.loading-spinner');
      const text=button.querySelector('.btn-text');
      if(isLoading){ spinner.style.display='inline-block'; text.textContent='Loading...'; button.disabled=true; }
      else{ spinner.style.display='none'; text.textContent = button.id==='loadTrendsBtn'?'Load Trends':(button.id==='loadAnalyticsBtn'?'Load Range':'Load Evaluations'); button.disabled=false; }
    }
    
    // ===== Progress Bar Functions =====
    function updateProgress(p,cur,total){ 
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
      const chunkText = document.getElementById('chunkText');
      
      if (progressFill) progressFill.style.width = `${p}%`; 
      if (progressText) progressText.textContent = `${Math.round(p)}%`; 
      if (chunkText) chunkText.textContent = `Processing...`; 
    }
    
    function showProgress(){ 
      const progressSection = document.getElementById('progressSection');
      if (progressSection) progressSection.style.display='block'; 
    }
    
    function hideProgress(){ 
      const progressSection = document.getElementById('progressSection');
      if (progressSection) progressSection.style.display='none'; 
    }

    // ===== Date Range Selector Functions (from the first code) =====
    function initializeDateRangeSelector() {
      // Set default dates (last 7 days)
      const today = new Date();
      const weekAgo = new Date();
      weekAgo.setDate(today.getDate() - 7);
      
      state.dateRangeState.startDate = weekAgo;
      state.dateRangeState.endDate = today;
      
      updateDateRangeDisplay();
      updateHiddenDateInputs();
      updateCalendar();
    }
    
    function updateHiddenDateInputs() {
      if (state.dateRangeState.startDate) {
        document.getElementById('fromDate').value = state.dateRangeState.startDate.toISOString().split('T')[0];
      }
      if (state.dateRangeState.endDate) {
        document.getElementById('toDate').value = state.dateRangeState.endDate.toISOString().split('T')[0];
      }
    }
    
    function updateDateRangeDisplay() {
      const valueElement = document.getElementById('date-range-value');
      if (state.dateRangeState.startDate && state.dateRangeState.endDate) {
        const startStr = formatDateDisplay(state.dateRangeState.startDate);
        const endStr = formatDateDisplay(state.dateRangeState.endDate);
        valueElement.textContent = `${startStr} - ${endStr}`;
      } else if (state.dateRangeState.startDate) {
        const startStr = formatDateDisplay(state.dateRangeState.startDate);
        valueElement.textContent = `${startStr} (Select end date)`;
      } else {
        valueElement.textContent = 'Select date range';
      }
    }
    
    function formatDateDisplay(date) {
      return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
      });
    }
    
    function isSameDay(date1, date2) {
      return date1.getFullYear() === date2.getFullYear() &&
             date1.getMonth() === date2.getMonth() &&
             date1.getDate() === date2.getDate();
    }
    
    function isDateInRange(date) {
      if (!state.dateRangeState.startDate || !state.dateRangeState.endDate) return false;
      return date >= state.dateRangeState.startDate && date <= state.dateRangeState.endDate;
    }
    
    function getWeekStartDate(date) {
      const result = new Date(date);
      const day = result.getDay();
      const diff = result.getDate() - day;
      result.setDate(diff);
      return result;
    }
    
    function getWeekEndDate(date) {
      const result = new Date(date);
      const day = result.getDay();
      const diff = result.getDate() + (6 - day);
      result.setDate(diff);
      return result;
    }
    
    function updateCalendar() {
      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
          'July', 'August', 'September', 'October', 'November', 'December'];
      const year = state.dateRangeState.currentDate.getFullYear();
      const month = state.dateRangeState.currentDate.getMonth();
      document.getElementById('current-month').textContent = `${monthNames[month]} ${year}`;
      
      // Clear calendar
      const calendarDaysElement = document.getElementById('calendar-days');
      calendarDaysElement.innerHTML = '';
      
      // Get first day of month and total days
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const daysInMonth = lastDay.getDate();
      const startingDay = firstDay.getDay(); // 0 = Sunday
      
      const today = new Date();
      
      // Add days from previous month (now selectable)
      if (startingDay > 0) {
        const prevMonthLastDay = new Date(year, month, 0).getDate();
        for (let i = startingDay - 1; i >= 0; i--) {
          const prevMonthDay = prevMonthLastDay - i;
          const dayDate = new Date(year, month - 1, prevMonthDay);
          const dayElement = createDayElement('calendar-day other-month', prevMonthDay);
          
          // Check if this day is selected
          applySelectionClasses(dayElement, dayDate, today);
          
          // Add click event for selecting dates
          dayElement.addEventListener('click', (e) => {
            e.stopPropagation();
            handleDateClick(dayDate);
          });
          
          calendarDaysElement.appendChild(dayElement);
        }
      }
      
      // Add days of the current month
      for (let day = 1; day <= daysInMonth; day++) {
        const dayDate = new Date(year, month, day);
        const dayElement = createDayElement('calendar-day', day);
        
        // Check if this day is selected
        applySelectionClasses(dayElement, dayDate, today);
        
        // Add click event for selecting dates
        dayElement.addEventListener('click', (e) => {
          e.stopPropagation();
          handleDateClick(dayDate);
        });
        
        calendarDaysElement.appendChild(dayElement);
      }
      
      // Calculate how many cells we've added so far
      const totalCellsSoFar = startingDay + daysInMonth;
      const cellsNeededForFullGrid = 42; // 6 rows * 7 days
      
      // Add days from next month to complete the grid (now selectable)
      if (totalCellsSoFar < cellsNeededForFullGrid) {
        for (let i = 1; i <= (cellsNeededForFullGrid - totalCellsSoFar); i++) {
          const dayDate = new Date(year, month + 1, i);
          const dayElement = createDayElement('calendar-day other-month', i);
          
          // Check if this day is selected
          applySelectionClasses(dayElement, dayDate, today);
          
          // Add click event for selecting dates
          dayElement.addEventListener('click', (e) => {
            e.stopPropagation();
            handleDateClick(dayDate);
          });
          
          calendarDaysElement.appendChild(dayElement);
        }
      }
      
      // Update apply button state
      document.getElementById('apply-calendar-btn').disabled = !(state.dateRangeState.startDate && state.dateRangeState.endDate);
    }
    
    function createDayElement(className, day) {
      const dayElement = document.createElement('div');
      dayElement.className = className;
      if (day) dayElement.textContent = day;
      return dayElement;
    }
    
    function applySelectionClasses(dayElement, dayDate, today) {
      const isToday = isSameDay(dayDate, today);
      const isStartDate = state.dateRangeState.startDate && isSameDay(dayDate, state.dateRangeState.startDate);
      const isEndDate = state.dateRangeState.endDate && isSameDay(dayDate, state.dateRangeState.endDate);
      const isInRange = isDateInRange(dayDate);
      
      if (isToday) dayElement.classList.add('today');
      if (isInRange) dayElement.classList.add('in-range');
      if (isStartDate) dayElement.classList.add('range-start');
      if (isEndDate) dayElement.classList.add('range-end');
    }
    
    function handleDateClick(date) {
      if (!state.dateRangeState.startDate || (state.dateRangeState.startDate && state.dateRangeState.endDate)) {
        // Start new selection
        state.dateRangeState.startDate = new Date(date);
        state.dateRangeState.endDate = null;
        state.dateRangeState.isSelectingRange = true;
        
        // Update current month view to show the selected month
        const clickedMonth = date.getMonth();
        const clickedYear = date.getFullYear();
        
        // Only update currentDate if the clicked date is from a different month
        if (clickedMonth !== state.dateRangeState.currentDate.getMonth() || clickedYear !== state.dateRangeState.currentDate.getFullYear()) {
          state.dateRangeState.currentDate = new Date(clickedYear, clickedMonth, 1);
        }
        
        // Update preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelector('[data-preset="custom"]').classList.add('active');
      } else if (state.dateRangeState.isSelectingRange) {
        // Complete the range selection
        if (date < state.dateRangeState.startDate) {
          state.dateRangeState.endDate = new Date(state.dateRangeState.startDate);
          state.dateRangeState.startDate = new Date(date);
        } else {
          state.dateRangeState.endDate = new Date(date);
        }
        state.dateRangeState.isSelectingRange = false;
        
        // Update current month view to show the start date month
        const clickedMonth = state.dateRangeState.startDate.getMonth();
        const clickedYear = state.dateRangeState.startDate.getFullYear();
        
        // Only update currentDate if the start date is from a different month
        if (clickedMonth !== state.dateRangeState.currentDate.getMonth() || clickedYear !== state.dateRangeState.currentDate.getFullYear()) {
          state.dateRangeState.currentDate = new Date(clickedYear, clickedMonth, 1);
        }
      }
      
      updateDateRangeDisplay();
      updateSelectedRangeDisplay();
      updateCalendar();
    }
    
    function updateSelectedRangeDisplay() {
      if (state.dateRangeState.startDate && state.dateRangeState.endDate) {
        const startStr = formatDateDisplay(state.dateRangeState.startDate);
        const endStr = formatDateDisplay(state.dateRangeState.endDate);
        document.getElementById('selected-range').textContent = `${startStr} - ${endStr}`;
      } else if (state.dateRangeState.startDate) {
        const startStr = formatDateDisplay(state.dateRangeState.startDate);
        document.getElementById('selected-range').textContent = `${startStr} (Select end date)`;
      } else {
        document.getElementById('selected-range').textContent = 'Select a date range';
      }
    }
    
    function openCalendar() {
      document.getElementById('calendar-overlay').classList.add('active');
      document.body.style.overflow = 'hidden';
    }
    
    function closeCalendar() {
      document.getElementById('calendar-overlay').classList.remove('active');
      document.body.style.overflow = 'auto';
    }
    
    function setupCalendarEvents() {
      // Open calendar
      document.getElementById('date-range-input').addEventListener('click', openCalendar);
      
      // Close calendar when clicking on overlay
      document.getElementById('calendar-overlay').addEventListener('click', function(e) {
        if (e.target === document.getElementById('calendar-overlay')) closeCalendar();
      });
      
      // Month navigation
      document.getElementById('prev-month').addEventListener('click', (e) => {
        e.stopPropagation();
        state.dateRangeState.currentDate.setMonth(state.dateRangeState.currentDate.getMonth() - 1);
        updateCalendar();
      });
      
      document.getElementById('next-month').addEventListener('click', (e) => {
        e.stopPropagation();
        state.dateRangeState.currentDate.setMonth(state.dateRangeState.currentDate.getMonth() + 1);
        updateCalendar();
      });
      
      document.getElementById('today-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        state.dateRangeState.currentDate = new Date();
        updateCalendar();
      });
      
      // Clear selection
      document.getElementById('clear-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        state.dateRangeState.startDate = null;
        state.dateRangeState.endDate = null;
        updateDateRangeDisplay();
        updateSelectedRangeDisplay();
        updateCalendar();
        document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelector('[data-preset="custom"]').classList.add('active');
      });
      
      // Apply calendar selection
      document.getElementById('apply-calendar-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        if (state.dateRangeState.startDate && state.dateRangeState.endDate) {
          updateDateRangeDisplay();
          updateHiddenDateInputs();
          closeCalendar();
          updateMonthRange(); // Update the month range based on date range
        } else {
          alert('Please select a date range first.');
        }
      });
      
      // Preset button functionality
      document.querySelectorAll('.preset-btn').forEach(button => {
        button.addEventListener('click', function(e) {
          e.stopPropagation();
          document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
          this.classList.add('active');
          
          const preset = this.dataset.preset;
          const today = new Date();
          
          switch(preset) {
            case 'today':
              state.dateRangeState.startDate = new Date(today);
              state.dateRangeState.endDate = new Date(today);
              break;
            case 'yesterday':
              const yesterday = new Date(today);
              yesterday.setDate(yesterday.getDate() - 1);
              state.dateRangeState.startDate = yesterday;
              state.dateRangeState.endDate = yesterday;
              break;
            case 'thisWeek':
              state.dateRangeState.startDate = getWeekStartDate(today);
              state.dateRangeState.endDate = getWeekEndDate(today);
              break;
            case 'lastWeek':
              const lastWeek = new Date(today);
              lastWeek.setDate(lastWeek.getDate() - 7);
              state.dateRangeState.startDate = getWeekStartDate(lastWeek);
              state.dateRangeState.endDate = getWeekEndDate(lastWeek);
              break;
            case 'custom':
              break;
          }
          
          if (state.dateRangeState.startDate) {
            state.dateRangeState.currentDate = new Date(state.dateRangeState.startDate);
          }
          
          updateDateRangeDisplay();
          updateSelectedRangeDisplay();
          updateCalendar();
          updateHiddenDateInputs();
          updateMonthRange(); // Update the month range based on date range
        });
      });
      
      // Close on Escape key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && document.getElementById('calendar-overlay').classList.contains('active')) {
          closeCalendar();
        }
      });
    }

    // ===== Checkbox dropdown =====
    function createCheckboxDropdown(containerId,{placeholder,searchPlaceholder}){
      const root=document.getElementById(containerId); root.innerHTML='';
      const trigger=document.createElement('div'); trigger.className='cd-trigger';
      trigger.innerHTML=`<span class="label">${placeholder}</span><span class="count">0 selected</span>`;
      root.appendChild(trigger);
      const panel=document.createElement('div'); panel.className='cd-panel';
      panel.innerHTML=`
        <div class="cd-header">
          <input type="text" class="cd-search" placeholder="${searchPlaceholder}" />
          <div class="cd-actions"><button type="button" data-cd="clear">Clear</button></div>
        </div>
        <div class="cd-selectall"><label><input type="checkbox" data-cd="selectall"/> Select all</label></div>
        <div class="cd-list"></div>
        <div class="cd-footer"><span data-cd="summary">0 selected</span><span>Click outside to close</span></div>`;
      root.appendChild(panel);

      const list=panel.querySelector('.cd-list');
      const search=panel.querySelector('.cd-search');
      const clearBtn=panel.querySelector('[data-cd="clear"]');
      const selectAll=panel.querySelector('[data-cd="selectall"]');
      const summary=panel.querySelector('[data-cd="summary"]');

      let options=[]; let selected=new Set();

      function render(filter=''){
        const ft=filter.trim().toLowerCase(); list.innerHTML='';
        const filtered=!ft?options:options.filter(o=>(o.label||'').toLowerCase().includes(ft));
        if(!filtered.length){ list.innerHTML=`<div class="cd-item" style="color:#6C757D">No matches</div>`; return; }
        filtered.forEach(o=>{
          const id=`${containerId}__${o.value}`;
          const row=document.createElement('div'); row.className='cd-item';
          row.innerHTML=`<label for="${id}"><input type="checkbox" id="${id}" value="${o.value}" ${selected.has(o.value)?'checked':''}/><span>${o.label||o.value}</span></label>`;
          row.querySelector('input').addEventListener('change',(e)=>{
            if(e.target.checked) selected.add(o.value);
            else selected.delete(o.value);
            updateSummary();
            updateSelectAllState();
            if(containerId !== 'analyticsTeamDropdown' && containerId !== 'trendTeamDropdown') updateLoadButtonState();
          });
          list.appendChild(row);
        });
      }
      function updateSummary(){ trigger.querySelector('.count').textContent=`${selected.size} selected`; summary.textContent=`${selected.size} selected`; }
      function updateSelectAllState(){ const total=options.length,count=selected.size; selectAll.indeterminate=count>0&&count<total; selectAll.checked=total>0&&count===total; }

      trigger.addEventListener('click',()=>{ panel.classList.toggle('open'); search.focus(); });
      document.addEventListener('click',(e)=>{ if(!root.contains(e.target)) panel.classList.remove('open'); });
      search.addEventListener('input',()=>render(search.value));
      clearBtn.addEventListener('click',()=>{ selected.clear(); render(search.value); updateSummary(); updateSelectAllState(); if(containerId !== 'analyticsTeamDropdown' && containerId !== 'trendTeamDropdown') updateLoadButtonState(); });
      selectAll.addEventListener('change',()=>{ if(selectAll.checked) options.forEach(o=>selected.add(o.value)); else selected.clear(); render(search.value); updateSummary(); if(containerId !== 'analyticsTeamDropdown' && containerId !== 'trendTeamDropdown') updateLoadButtonState(); });

      function setOptions(newOptions){ options=newOptions||[]; selected.forEach(v=>{ if(!options.some(o=>o.value===v)) selected.delete(v); }); render(search.value); updateSummary(); updateSelectAllState(); if(containerId !== 'analyticsTeamDropdown' && containerId !== 'trendTeamDropdown') updateLoadButtonState(); }
      function getSelectedValues(){ return Array.from(selected); }

      render(''); return { setOptions, getSelectedValues };
    }

    function updateLoadButtonState(){
      const hasUsers=dropdowns.users && dropdowns.users.getSelectedValues().length>0;
      const hasTeams=dropdowns.teams && dropdowns.teams.getSelectedValues().length>0;
      const hasForms=dropdowns.forms && dropdowns.forms.getSelectedValues().length>0;
      document.getElementById('loadBtn').disabled=!((hasUsers || hasTeams || hasForms));
    }

    // ===== Main Tab Switching Function =====
    function setupMainTabSwitching() {
      document.addEventListener("click", function(e) {
        if (!e.target.classList.contains("main-tab-button")) return;

        // Handle main tabs (Quality Reporting vs How to Use)
        document.querySelectorAll(".main-tab-button").forEach(btn =>
          btn.classList.remove("active")
        );
        e.target.classList.add("active");

        const target = e.target.dataset.tab;

        document.querySelectorAll(".main-tab-content").forEach(tab =>
          tab.classList.remove("active")
        );
        document.getElementById(target).classList.add("active");
      });
    }

    // ===== Boot (handles errors + expiry, avoids redirect loops) =====
    document.addEventListener('DOMContentLoaded', function () {
      resolveColors();
      setupMainTabSwitching();
      console.log('DOM loaded, starting OAuth flow...');

      const rawHash = (window.location.hash || '').replace(/^#/, '');
      const params = new URLSearchParams(rawHash);

      // 1) OAuth error (prevents infinite redirect)
      const oauthError = params.get('error');
      if (oauthError) {
        const desc = decodeURIComponent(params.get('error_description') || '');
        console.error('OAuth error:', oauthError, desc);
        history.replaceState(null, document.title, window.location.pathname + window.location.search);
        sessionStorage.removeItem('purecloud_token');
        sessionStorage.removeItem('purecloud_token_exp');

        document.getElementById('auth-message').textContent = 'Sign-in failed. Please refresh the page to try again.';
        document.getElementById('auth-message').className = 'error-message';
        return;
      }

      // 2) Token in hash
      const tokenFromHash = params.get('access_token');
      if (tokenFromHash) {
        console.log('Token found in hash');
        const expiresIn = parseInt(params.get('expires_in') || '0', 10);
        const expAt = expiresIn ? Date.now() + (expiresIn - 60) * 1000 : 0; // pad by 60s
        sessionStorage.setItem('purecloud_token', tokenFromHash);
        if (expAt) sessionStorage.setItem('purecloud_token_exp', String(expAt));
        history.replaceState(null, document.title, window.location.pathname + window.location.search);
        startApp(tokenFromHash);
        return;
      }

      // 3) Token from session (if not expired)
      const tokenFromSession = sessionStorage.getItem('purecloud_token');
      const exp = parseInt(sessionStorage.getItem('purecloud_token_exp') || '0', 10);
      if (tokenFromSession && (!exp || Date.now() < exp)) {
        console.log('Token found in session storage');
        startApp(tokenFromSession);
        return;
      }

      // 4) No token yet - redirect to OAuth
      console.log('No token found, redirecting to OAuth');
      document.getElementById('auth-message').textContent = 'Redirecting to Genesys Cloud for authentication...';
      setTimeout(function(){ window.location.href = oauthUrl; }, 200);
    });

    // ===== Agent Insights Renderer (Moved before startApp) =====
    function renderAgentInsights(){
      const data = window._insightData || [];
      const mode = document.getElementById('insightsSort').value || 'avgDesc';
      const arr = (function sort(mode, a){
        const x=[...a];
        if(mode==='avgAsc') x.sort((u,v)=>(u.avg??-1)-(v.avg??-1));
        else if(mode==='avgDesc') x.sort((u,v)=>(v.avg??-1)-(u.avg??-1));
        else if(mode==='failsDesc') x.sort((u,v)=>v.fails-u.fails);
        else if(mode==='evalsDesc') x.sort((u,v)=>v.count-u.count);
        return x;
      })(mode, data);

      const html = arr.map(a=>{
        const w = a.avg==null?0:Math.max(0,Math.min(100,a.avg));
        return `<div class="insight-row">
          <div class="insight-name">${a.name}</div>
          <div class="insight-bar-wrap"><div class="insight-bar" style="width:${w}%"></div></div>
          <div class="insight-meta">${pct(a.avg??0,1)} <span class="pill">Evals ${a.count}</span><span class="pill">Fails ${a.fails}</span></div>
        </div>`;
      }).join('');
      document.getElementById('agentInsights').innerHTML = html || '<div class="muted">No agent data.</div>';
    }

    function startApp(token){
      console.log('Starting app with token');
      state.accessToken=token;
      document.getElementById('auth-message').textContent='Authenticated successfully!';
      document.getElementById('auth-message').className='success-message';
      setTimeout(()=>{ document.getElementById('authCard').style.display='none'; }, 800);
      document.getElementById('appContent').style.display='block';

      dropdowns.users=createCheckboxDropdown('userDropdown',{placeholder:'Select agents (optional)',searchPlaceholder:'Search agents...'});
      dropdowns.teams=createCheckboxDropdown('teamDropdown',{placeholder:'Select work teams (optional)',searchPlaceholder:'Search teams...'});
      dropdowns.forms=createCheckboxDropdown('formDropdown',{placeholder:'Select forms (optional)',searchPlaceholder:'Search forms...'});
      dropdowns.analyticsTeams=createCheckboxDropdown('analyticsTeamDropdown',{placeholder:'Filter teams (optional)',searchPlaceholder:'Search teams...'});
      dropdowns.trendTeams=createCheckboxDropdown('trendTeamDropdown',{placeholder:'Filter teams (optional)',searchPlaceholder:'Search teams...'});

      // ORIGINAL tab event listeners - UNCHANGED
      document.getElementById('overviewTabButton').onclick=()=>setTab('overview');
      document.getElementById('analyticsTabButton').onclick=()=>{
        setTab('analytics');
        // FIX 1: Added setTimeout to ensure DOM is ready before rendering charts
        setTimeout(() => renderAnalytics(), 100);
      };
      document.getElementById('trendsTabButton').onclick=()=>setTab('trends');
      document.getElementById('detailsTabButton').onclick=()=>setTab('details');
      document.getElementById('criticalTabButton').onclick=()=>setTab('critical');
      document.getElementById('loadBtn').onclick=loadEvaluations;

      document.getElementById('loadAnalyticsBtn').onclick=loadAnalyticsRange;
      document.getElementById('loadTrendsBtn').onclick=loadTrendsData;
      document.getElementById('insightsSort').onchange=renderAgentInsights;
      document.getElementById('trendPeriodSelect').onchange=renderTrends;
      
      // New event listeners for details filters
      document.getElementById('applyFiltersBtn').onclick=applyDetailsFilters;

      // Initialize date range selector
      initializeDateRangeSelector();
      setupCalendarEvents();

      // Set default month values based on date range
      const m=new Date();
      const cur=`${m.getFullYear()}-${String(m.getMonth()+1).padStart(2,'0')}`;
      document.getElementById('anaFrom').value = cur;
      document.getElementById('anaTo').value = cur;
      document.getElementById('trendFrom').value = cur;
      document.getElementById('trendTo').value = cur;

      updateMonthRange();

      Promise.all([fetchAllUsers(), fetchAllTeams(), fetchAllForms()])
        .then(()=> {
          updateLoadButtonState();
          dropdowns.analyticsTeams.setOptions(state.teams.map(t=>({value:t.id,label:t.name})));
          dropdowns.trendTeams.setOptions(state.teams.map(t=>({value:t.id,label:t.name})));
        })
        .catch(err => {
          console.error('Initial load failed:', err);
          msg('Initial load failed: '+err.message,'error');
        });
    }

    function setTab(name){
      ['overview','analytics','trends','details','critical'].forEach(n=>{
        document.getElementById(`${n}Tab`).classList.toggle('active', n===name);
        document.getElementById(`${n}TabButton`).classList.toggle('active', n===name);
      });
      if(name==='analytics') {
        // FIX 2: Added delay when switching to analytics tab
        setTimeout(() => renderAnalytics(), 100);
      }
      if(name==='details') renderDetails();
      if(name==='critical') renderCritical();
      if(name==='trends') renderTrends();
    }

    function updateMonthRange(){
      // Use the date range from the date picker instead of month input
      const from = document.getElementById('fromDate').value;
      const to = document.getElementById('toDate').value || from;
      
      if(!from) return;
      
      const fromDate = new Date(from);
      const toDate = to ? new Date(to) : new Date(from);
      
      // Set to end of day for toDate
      toDate.setHours(23, 59, 59, 999);
      
      state.monthStart = fromDate;
      state.monthEnd = toDate;
    }

    // ===== HTTP helper with spacing + retry/backoff =====
    async function rawFetch(url,options={}){
      const now=Date.now(); const delta=now-lastApiCall;
      if(delta<API_DELAY) await sleep(API_DELAY-delta);
      lastApiCall=Date.now();
      return fetch(url,{...options,headers:{'Authorization':'Bearer '+state.accessToken,'Content-Type':'application/json',...(options.headers||{})}});
    }

    async function fetchJsonWithRetry(url, options={}, {retries=5, baseDelay=500}={}){
      let attempt=0;
      while(true){
        const res = await rawFetch(url, options);
        if(res.ok){
          if(res.status===204) return null;
          return await res.json();
        }
        if([400,401,403,404,405].includes(res.status)){
          if(res.status === 401 || res.status === 403) {
            // Token expired or invalid
            sessionStorage.removeItem('purecloud_token');
            sessionStorage.removeItem('purecloud_token_exp');
            document.getElementById('appContent').style.display='none';
            document.getElementById('authCard').style.display='block';
            document.getElementById('auth-message').textContent='Session expired. Redirecting to login...';
            document.getElementById('auth-message').className='info-message';
            setTimeout(() => { window.location.href = oauthUrl; }, 2000);
            throw new Error('Authentication required');
          }
          const err=new Error(`HTTP ${res.status}`); err.status=res.status; throw err;
        }
        attempt++;
        if(attempt>retries){
          const err=new Error(`HTTP ${res.status}`); err.status=res.status; throw err;
        }
        const retryAfter = Number(res.headers.get('Retry-After')) || null;
        const delay = retryAfter ? retryAfter*1000 : Math.round(baseDelay * (2**(attempt-1)) * (1 + Math.random()*0.25));
        await sleep(delay);
      }
    }

    async function fetchPaginatedGET(url){
      let all=[]; let next=url;
      while(next){
        const data = await fetchJsonWithRetry(next, {method:'GET'});
        if(Array.isArray(data.entities)) all=all.concat(data.entities);
        else if(Array.isArray(data.users)) all=all.concat(data.users);
        else if(Array.isArray(data)) all=all.concat(data);
        else if(data.entities) all=all.concat(data.entities);
        next = data.nextUri ? `https://api.${config.REGION}${data.nextUri}` : null;
      }
      return all;
    }

    function safeGet(o,p,def=null){ try{ return p.split('.').reduce((x,k)=>(x && k in x)?x[k]:undefined ,o) ?? def; }catch{ return def; } }
    function pct(n,d=1){ if(n==null||!isFinite(n)) return '-'; return (Math.round(n*10**d)/10**d).toFixed(d)+'%'; }
    function fmt(n,d=1){ if(n==null||!isFinite(n)) return '-'; return (Math.round(n*10**d)/10**d).toFixed(d); }
    function toUKDate(d){ const dt=new Date(d); return dt.toLocaleDateString('en-GB'); }
    function toDateTime(d){ const dt=new Date(d); return dt.toLocaleString('en-GB'); }
    function dayKeyUTC(d){ const dt=new Date(d); return new Date(Date.UTC(dt.getUTCFullYear(),dt.getUTCMonth(),dt.getUTCDate())).toISOString().split('T')[0]; }
    function getWeekNumber(d) {
      const date = new Date(d);
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      const week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
    }
    function formatWeek(d) {
      const date = new Date(d);
      const weekNum = getWeekNumber(d);
      return `Week ${weekNum}, ${date.getFullYear()}`;
    }

    // Analytics helper functions
    function getPassSettings(){
      const pass=parseFloat(document.getElementById('passTarget').value||'85');
      const band=parseFloat(document.getElementById('amberBand').value||'5');
      return {pass, band};
    }
    
    function getTrendPassSettings(){
      const pass=parseFloat(document.getElementById('trendPassTarget').value||'85');
      const band=parseFloat(document.getElementById('trendAmberBand').value||'5');
      return {pass, band};
    }

    function colourFor(score, pass, band){
      if(score==null||!isFinite(score)) return COLORS.BAD;
      if(score>=pass) return COLORS.OK;
      if(score>=pass-band) return COLORS.WARN;
      return COLORS.BAD;
    }

    function standardiseMedia(m){
      const x=String(m||'').toUpperCase();
      if(x.includes('EMAIL')) return 'Email';
      if(x.includes('CALL')||x.includes('VOICE')||x==='CALL') return 'Voice';
      if(x.includes('CHAT')||x.includes('MESSAGE')) return 'Message';
      if(x.includes('SOCIAL')) return 'Social';
      return 'Other';
    }

    // Improved critical/fatal detection
    function getMaxScoreForQuestion(questionObj) {
      const opts = [...(questionObj?.answerOptions || []), ...(questionObj?.options || [])];
      if (opts.length > 0) { return Math.max(...opts.map(opt => Number(opt.value) || 0)); }
      return Number(questionObj?.maxScore) || 1;
    }

    function detectCriticalFatalQuestions(qScore, questionObj) {
      const isFatal = !!(qScore.failedKillQuestion || qScore.isKill || qScore.isFatal);
      const explicitCritFail = !!(qScore.failedCriticalQuestion);
      if (qScore.notApplicable) {
        return { isFatal, isCritical: explicitCritFail };
      }
      const criticalFlag = !!( qScore.isCritical || safeGet(qScore,'question.isCritical') || safeGet(questionObj,'criticalQuestion') || safeGet(questionObj,'isCritical') );
      const maxScore = getMaxScoreForQuestion(questionObj || {});
      let currentScore = Number(qScore.score);
      if (!isFinite(currentScore)) currentScore = 0;
      const markdownByScore = criticalFlag && maxScore > 0 && currentScore < maxScore;
      return { isFatal, isCritical: explicitCritFail || markdownByScore };
    }

    // Enhanced contact info extraction - prioritizes ANI from API
    function extractContactInfo(e) {
      const conversation = e.conversation || {};
      let contactInfo = '';
      
      // Try to get phone number (ANI) - this is what we want for +44 numbers
      const ani = conversation.ani || conversation.fromAddress || conversation.callerAddress;
      if (ani) {
        // Format as +44 number if it starts with 44 or 0
        let formattedAni = ani;
        if (ani.startsWith('44')) {
          formattedAni = '+' + ani;
        } else if (ani.startsWith('0')) {
          formattedAni = '+44' + ani.substring(1);
        }
        contactInfo = `Phone: ${formattedAni}`;
      }
      
      // Try to get email address
      const email = conversation.emailAddress || conversation.fromEmail || conversation.customerEmail;
      if (email) {
        if (contactInfo) contactInfo += ' | ';
        contactInfo += `Email: ${email}`;
      }
      
      // Try to get other contact info
      if (!contactInfo) {
        const address = conversation.address || conversation.customerAddress;
        if (address) {
          contactInfo = `Contact: ${address}`;
        }
      }
      
      return contactInfo || 'No contact info';
    }

    // ===== Lookups =====
    async function fetchAllUsers(){
      try {
        console.log('Fetching users...');
        const url=`https://api.${config.REGION}/api/v2/users?pageSize=100`;
        const users=await fetchPaginatedGET(url);
        state.users=users.map(u=>({id:u.id,name:(u.name || `${u.givenName||''} ${u.familyName||''}`).trim(),email:u.email||''})).sort((a,b)=>a.name.localeCompare(b.name));
        dropdowns.users.setOptions(state.users.map(u=>({value:u.id,label:`${u.name}${u.email?` â€” ${u.email}`:''}`})));
        console.log(`Loaded ${state.users.length} users`);
      } catch (err) {
        console.error('Failed to fetch users:', err);
        throw new Error('Failed to load users: ' + err.message);
      }
    }

    async function fetchAllTeams(){
      try {
        console.log('Fetching teams...');
        const url=`https://api.${config.REGION}/api/v2/teams?pageSize=100`;
        const teams = await fetchPaginatedGET(url);
        state.teams = teams.map(t=>({id:t.id,name:t.name||'(Unnamed team)'})).sort((a,b)=>a.name.localeCompare(b.name));
        state.teamsById = Object.fromEntries(state.teams.map(t=>[t.id,t]));
        dropdowns.teams.setOptions(state.teams.map(t=>({value:t.id,label:t.name})));
        console.log(`Loaded ${state.teams.length} teams`);
      } catch (err) {
        console.error('Failed to fetch teams:', err);
        throw new Error('Failed to load teams: ' + err.message);
      }
    }

    async function ensureTeamMembersLoaded(teamIds){
      const missing = teamIds.filter(id=>!state.teamMembers.has(id));
      if(!missing.length) return;
      await Promise.all(missing.map(fetchTeamMembers));
    }

    async function fetchTeamMembers(teamId){
      const url=`https://api.${config.REGION}/api/v2/teams/${teamId}/members?pageSize=100`;
      const members=await fetchPaginatedGET(url);
      const ids = Array.from(new Set(members.map(m => safeGet(m,'member.id') || safeGet(m,'member.user.id') || safeGet(m,'user.id') || safeGet(m,'id')).filter(Boolean)));
      state.teamMembers.set(teamId, ids);
    }

    async function fetchAllForms(){
      try {
        console.log('Fetching forms...');
        const url=`https://api.${config.REGION}/api/v2/quality/forms/evaluations?pageSize=100`;
        const forms=await fetchPaginatedGET(url);
        state.forms=forms.map(f=>({id:f.id,name:f.name||f.title||'(Unnamed form)'})).sort((a,b)=>a.name.localeCompare(b.name));
        state.formsById=Object.fromEntries(state.forms.map(f=>[f.id,f]));
        dropdowns.forms.setOptions(state.forms.map(f=>({value:f.id,label:f.name})));
        console.log(`Loaded ${state.forms.length} forms`);
      } catch (err) {
        console.error('Failed to fetch forms:', err);
        throw new Error('Failed to load forms: ' + err.message);
      }
    }

    async function computeSelectedAgentIds(){
      const userIds = dropdowns.users.getSelectedValues();
      const teamIds = dropdowns.teams.getSelectedValues();
      const set = new Set(userIds);
      if(teamIds.length){
        await ensureTeamMembersLoaded(teamIds);
        teamIds.forEach(tid=>{
          (state.teamMembers.get(tid)||[]).forEach(uid=>set.add(uid));
        });
      }
      return Array.from(set);
    }

    // Helper for analytics team filtering
    async function agentsForTeams(teamIds){
      await ensureTeamMembersLoaded(teamIds);
      const ids=new Set();
      teamIds.forEach(tid=>(state.teamMembers.get(tid)||[]).forEach(id=>ids.add(id)));
      return Array.from(ids);
    }

    // ===== Date Range Chunking Functions (from the first code) =====
    function chunks(start,end,days){
      const out=[]; const s=new Date(start), e=new Date(end); let cur=new Date(s);
      while(cur<=e){ 
        let ce=new Date(cur); 
        ce.setDate(ce.getDate()+days-1); 
        if(ce>e) ce=new Date(e);
        out.push({
          start:cur.toISOString().slice(0,10), 
          end:ce.toISOString().slice(0,10)
        }); 
        cur.setDate(cur.getDate()+days);
      } 
      return out;
    }
    
    function optimalDays(start,end){
      const s=new Date(start), e=new Date(end), total=Math.ceil((e-s)/(1000*60*60*24))+1;
      if(total<=7) return 7; 
      if(total<=30) return 7; 
      if(total<=90) return 5; 
      if(total<=180) return 3; 
      return 2;
    }

    // ===== Evaluations with GET/POST fallback + retry =====
    async function loadEvaluations(){
      const agentIds = await computeSelectedAgentIds();
      const formIds = dropdowns.forms.getSelectedValues();

      if(agentIds.length===0 && formIds.length===0){
        msg('Please select at least one agent, team, or form.','error');
        return;
      }
      
      // Get dates from hidden inputs (populated by date range selector)
      const from = document.getElementById('fromDate').value;
      const to = document.getElementById('toDate').value || from;
      
      if(!from){ 
        msg('Please select a date range first', true); 
        return; 
      }
      
      const today = new Date().toISOString().split('T')[0];
      if(from > today || to > today) { 
        msg('Date range cannot be in the future', true); 
        return; 
      }

      const btn=document.getElementById('loadBtn'); setLoading(btn,true); 
      showProgress();
      updateProgress(0, 0, 1);
      msg('Loading evaluationsâ€¦','info');
      
      try{
        const agentList = agentIds.length ? agentIds : state.users.map(u=>u.id);
        
        // Use chunking for large date ranges
        const days = optimalDays(from, to);
        const dateChunks = chunks(from, to, days);
        
        document.getElementById('chunkInfo').innerHTML = 
          `Processing range: <strong>${from} to ${to}</strong><br>Split into <strong>${dateChunks.length} chunks</strong> of ${days} days.`;

        state.evals = [];
        
        for(let i=0; i<dateChunks.length; i++){
          const ch = dateChunks[i]; 
          updateProgress((i/dateChunks.length)*100, i+1, dateChunks.length);
          msg(`Fetching chunk ${i+1}/${dateChunks.length}: ${ch.start} â†’ ${ch.end}`, 'info');
          
          try{
            const chunkEvals = await fetchDetailedEvaluations(agentList, formIds, new Date(ch.start), new Date(ch.end + 'T23:59:59'));
            state.evals = state.evals.concat(chunkEvals);
          }catch(e){ 
            console.error('Error in chunk:', e); 
            msg('Warning: failed chunk ' + (i+1) + ', continuingâ€¦', true); 
          }
          
          // Small delay between chunks to avoid rate limiting
          if(i<dateChunks.length-1) await new Promise(r=>setTimeout(r,400));
        }

        updateProgress(100, dateChunks.length, dateChunks.length);
        
        // CRITICAL FIX: Load ALL form details for ALL forms found in evaluations
        await loadAllFormDetailsFromEvaluations(state.evals);
        
        msg(`Loaded ${state.evals.length} evaluations.`,'success');
        renderAll();
        
        // FIX 3: Removed auto-load analytics and trends data
        // Charts will load when user switches to those tabs
      }catch(e){ console.error(e); msg('Failed to load evaluations: '+e.message,'error'); }
      finally{ 
        setLoading(btn,false); 
        hideProgress();
      }
    }

    async function loadAnalyticsRange(){
      const from=document.getElementById('anaFrom').value;
      const to=document.getElementById('anaTo').value;
      if(!from || !to){ msg('Select both From and To months for Analytics.','error'); return; }
      const [fy,fm]=from.split('-').map(Number);
      const [ty,tm]=to.split('-').map(Number);
      const start=new Date(Date.UTC(fy, fm-1, 1, 0,0,0));
      const end  =new Date(Date.UTC(ty, tm,   0, 23,59,59));
      if(start>end){ msg('The From month must be before the To month.','error'); return; }

      const formIds = dropdowns.forms.getSelectedValues();
      const agentIds = await computeSelectedAgentIds();
      if(agentIds.length===0 && formIds.length===0){
        msg('Please select at least one agent, team, or form.','error'); return;
      }

      const btn=document.getElementById('loadAnalyticsBtn'); setLoading(btn,true);
      try{
        const agentList = agentIds.length ? agentIds : state.users.map(u=>u.id);
        const data=await fetchDetailedEvaluations(agentList,formIds,start,end);
        state.analyticsEvals=data; state.analyticsRange={start,end};
        
        // CRITICAL FIX: Load ALL form details for ALL forms found in analytics evaluations
        await loadAllFormDetailsFromEvaluations(data);
        
        msg(`Analytics range loaded: ${data.length} evaluations.`, 'success');
        
        // FIX 4: Force render after loading analytics data
        if (document.getElementById('analyticsTab').classList.contains('active')) {
          setTimeout(() => renderAnalytics(), 150);
        }
      }catch(e){ console.error(e); msg('Failed to load analytics range: '+e.message,'error'); }
      finally{ setLoading(btn,false); }
    }

    async function loadTrendsData(){
      const from=document.getElementById('trendFrom').value;
      const to=document.getElementById('trendTo').value;
      if(!from || !to){ msg('Select both From and To months for Trends.','error'); return; }
      const [fy,fm]=from.split('-').map(Number);
      const [ty,tm]=to.split('-').map(Number);
      const start=new Date(Date.UTC(fy, fm-1, 1, 0,0,0));
      const end  =new Date(Date.UTC(ty, tm,   0, 23,59,59));
      if(start>end){ msg('The From month must be before the To month.','error'); return; }

      const formIds = dropdowns.forms.getSelectedValues();
      const agentIds = await computeSelectedAgentIds();
      if(agentIds.length===0 && formIds.length===0){
        msg('Please select at least one agent, team, or form.','error'); return;
      }

      const btn=document.getElementById('loadTrendsBtn'); setLoading(btn,true);
      try{
        const agentList = agentIds.length ? agentIds : state.users.map(u=>u.id);
        const data=await fetchDetailedEvaluations(agentList,formIds,start,end);
        state.trendsEvals=data; state.trendsRange={start,end};
        
        // CRITICAL FIX: Load ALL form details for ALL forms found in trends evaluations
        await loadAllFormDetailsFromEvaluations(data);
        
        msg(`Trends data loaded: ${data.length} evaluations.`, 'success');
        renderTrends();
      }catch(e){ console.error(e); msg('Failed to load trends data: '+e.message,'error'); }
      finally{ setLoading(btn,false); }
    }

    // NEW FUNCTION: Load ALL form details from evaluations
    async function loadAllFormDetailsFromEvaluations(evaluations) {
      if (!evaluations || evaluations.length === 0) return;
      
      console.log('Loading form details for all evaluations...');
      
      // Collect ALL unique form IDs from evaluations
      const formPromises = new Set();
      
      evaluations.forEach(e => {
        const pubId = safeGet(e, 'evaluationForm.id');
        const formId = safeGet(e, 'form.id') || e.formId;
        const formVersionId = safeGet(e, 'form.versionId') || e.formVersionId || safeGet(e, 'form.version');
        
        // Add published form if exists
        if (pubId) {
          formPromises.add(getFormDetails(pubId, '__published__'));
        }
        
        // Add form with version if exists
        if (formId && formVersionId) {
          formPromises.add(getFormDetails(formId, formVersionId));
        }
        
        // Always add form without version as fallback
        if (formId) {
          formPromises.add(getFormDetails(formId, null));
        }
      });
      
      console.log(`Loading ${formPromises.size} form details...`);
      
      // Load all form details
      await Promise.allSettled(Array.from(formPromises));
      console.log('All form details loaded.');
    }

    async function fetchDetailedEvaluations(agentIds,formIds,startDate,endDate){
      const all=[];
      for(let i=0;i<agentIds.length;i+=MAX_CONCURRENT_AGENT_BATCH){
        const batch=agentIds.slice(i,i+MAX_CONCURRENT_AGENT_BATCH);
        const res=await Promise.all(batch.map(id=>fetchEvaluationsForAgentInterval(id,formIds,startDate,endDate)));
        res.forEach(items=>all.push(...items));
        if(i+MAX_CONCURRENT_AGENT_BATCH<agentIds.length) await sleep(300);
      }
      return all;
    }

    async function fetchEvaluationsForAgentInterval(agentId,formIds,startDate,endDate){
      const start=startDate.toISOString(); const end=endDate.toISOString();
      const base = `https://api.${config.REGION}/api/v2/quality/evaluations/query`;

      // Helper: GET path
      async function getViaGET(singleFormId){
        const params = new URLSearchParams({
          agentUserId: agentId,
          startTime: start,
          endTime: end,
          expandAnswerTotalScores: 'true',
          pageSize: '50'
        });
        if(singleFormId) params.set('formId', singleFormId);
        const url = `${base}?${params.toString()}`;
        let all=[]; let next=url;
        while(next){
          try{
            const data = await fetchJsonWithRetry(next,{method:'GET'});
            const entities = data?.entities || [];
            all = all.concat(entities);
            next = data?.nextUri ? `https://api.${config.REGION}${data.nextUri}` : null;
          }catch(err){ throw err; }
        }
        return all;
      }

      // Helper: POST path
      async function getViaPOST(){
        const url = base;
        const body = {
          agentUserIds: [agentId],
          interval: `${start}/${end}`,
          expandAnswerTotalScores: true,
          pageSize: 50
        };
        if(formIds && formIds.length>0) body.formIds = formIds;

        let page=1, all=[];
        while(true){
          body.pageNumber = page;
          try{
            const data = await fetchJsonWithRetry(url,{method:'POST',body:JSON.stringify(body)});
            const entities = data?.entities || [];
            if(!entities.length) break;
            all = all.concat(entities);
            if(!data.nextUri && entities.length < body.pageSize) break;
            page++;
          }catch(err){ throw err; }
        }
        return all;
      }

      if(!formIds || formIds.length<=1){
        try{ return await getViaGET(formIds?.[0]); }
        catch(err){ if(err.status===405 || err.status===400){ /* fallback */ } else throw err; }
      }

      try{ return await getViaPOST(); }
      catch(err){
        if(err.status===405 || err.status===400){ return await getViaGET(undefined); }
        throw err;
      }
    }

    // ===== Forms & lookups =====
    function formKey(formId, versionId){ 
      return (versionId === '__published__') ? `pub@${formId}` : `${formId}@${versionId || 'latest'}`; 
    }
    
    async function getFormDetails(formId, versionId){
      const key = formKey(formId, versionId);
      
      // Return cached if available
      if (state.formDetailsCache.has(key)) {
        return state.formDetailsCache.get(key);
      }
      
      let url;
      if (versionId === '__published__') {
        url = `https://api.${config.REGION}/api/v2/quality/publishedforms/evaluations/${formId}`;
      } else {
        url = versionId
          ? `https://api.${config.REGION}/api/v2/quality/forms/evaluations/${formId}/versions/${versionId}`
          : `https://api.${config.REGION}/api/v2/quality/forms/evaluations/${formId}`;
      }
      
      try {
        let data;
        try {
          data = await fetchJsonWithRetry(url, { method: 'GET' });
        } catch (err) {
          // If specific version fails, try to get the latest version
          if (versionId && versionId !== '__published__') {
            console.log(`Version ${versionId} not found for form ${formId}, trying latest version`);
            data = await fetchJsonWithRetry(
              `https://api.${config.REGION}/api/v2/quality/forms/evaluations/${formId}`, 
              { method: 'GET' }
            );
          } else {
            throw err;
          }
        }
        
        // Store in cache
        state.formDetailsCache.set(key, data);
        state.formLookupCache.set(key, buildFormLookup(data || {}));
        
        return data;
      } catch (e) {
        console.error(`Failed to load form ${key}:`, e.message);
        state.formDetailsCache.set(key, null);
        return null;
      }
    }

    // IMPROVED form lookup
    function buildFormLookup(form){
      const questionText = new Map();
      const answerText = new Map();
      const questionObj = new Map();
      
      if (!form) {
        return { questionText, answerText, questionObj };
      }

      function extractQuestionText(q) {
        return q.text || q.label || q.title || q.questionText || '';
      }

      function extractAnswerText(a) {
        return a.text || a.label || a.title || String(a.value || '');
      }

      function addQuestion(q) {
        if (!q) return;
        
        const qText = extractQuestionText(q);
        
        // Map ALL possible IDs
        const ids = [];
        if (q.id) ids.push(q.id);
        if (q.contextId) ids.push(q.contextId);
        if (q.questionId) ids.push(q.questionId);
        if (q.questionContextId) ids.push(q.questionContextId);
        
        // Map IDs to question text
        ids.forEach(id => {
          if (id && qText) {
            questionText.set(id, qText);
            questionObj.set(id, q);
          }
        });
        
        // Handle answer options
        (q.answerOptions || []).forEach(a => {
          const aText = extractAnswerText(a);
          const answerIds = [];
          
          if (a.id) answerIds.push(a.id);
          if (a.contextId) answerIds.push(a.contextId);
          if (a.answerId) answerIds.push(a.answerId);
          if (a.answerOptionId) answerIds.push(a.answerOptionId);
          
          answerIds.forEach(id => {
            if (id && aText) {
              answerText.set(id, aText);
            }
          });
        });
        
        // Handle nested questions
        (q.multipleSelectOptionQuestions || []).forEach(addQuestion);
        (q.nestedQuestions || []).forEach(addQuestion);
      }

      function walkQuestionGroups(groups) {
        (groups || []).forEach(g => {
          // Process questions in group
          (g.questions || []).forEach(addQuestion);
          // Recursively walk nested groups
          walkQuestionGroups(g.questionGroups || []);
        });
      }
      
      // Process top-level questions
      (form.questions || []).forEach(addQuestion);
      
      // Process question groups
      walkQuestionGroups(form.questionGroups || []);
      
      return { questionText, answerText, questionObj };
    }

    async function getCombinedLookupForEval(e){
      const pubId = safeGet(e, 'evaluationForm.id');
      const formId = safeGet(e, 'form.id') || e.formId;
      const formVersionId = safeGet(e, 'form.versionId') || e.formVersionId || safeGet(e, 'form.version');
      
      // Create cache key
      const comboKey = `${pubId || 'no-pub'}|${formId || 'no-form'}|${formVersionId || 'no-ver'}`;
      
      if (state.combinedLookupCache.has(comboKey)) {
        return state.combinedLookupCache.get(comboKey);
      }
      
      // Load BOTH published form AND specific form
      const loadPromises = [];
      
      // Always try published form first
      if (pubId) {
        loadPromises.push(getFormDetails(pubId, '__published__'));
      }
      
      // Try specific form version
      if (formId && formVersionId) {
        loadPromises.push(getFormDetails(formId, formVersionId));
      }
      
      // Always try form without version
      if (formId) {
        loadPromises.push(getFormDetails(formId, null));
      }
      
      // Wait for all form details to load
      const results = await Promise.allSettled(loadPromises);
      const details = results
        .filter(r => r.status === 'fulfilled' && r.value)
        .map(r => r.value);
      
      // Build combined lookup
      const merged = { 
        questionText: new Map(), 
        answerText: new Map(), 
        questionObj: new Map()
      };
      
      details.forEach(d => {
        const lk = buildFormLookup(d || {});
        lk.questionText.forEach((v, k) => merged.questionText.set(k, v));
        lk.answerText.forEach((v, k) => merged.answerText.set(k, v));
        lk.questionObj.forEach((v, k) => merged.questionObj.set(k, v));
      });
      
      // Get form name
      const formName = safeGet(e, 'evaluationForm.name') || 
                      safeGet(e, 'form.name') || 
                      (details[0]?.name) || 
                      '(Unknown Form)';
      
      const combined = {
        ...merged,
        formName,
        formId,
        formVersionId,
        pubId
      };
      
      state.combinedLookupCache.set(comboKey, combined);
      return combined;
    }

    // ===== IMPROVED Question Text Resolution =====
    function approx(a,b){ return Math.abs(Number(a)-Number(b))<1e-6; }
    
    function resolveQuestionTextWithLookup(lookup, qScore) {
      // Strategy 1: Try to get from qScore.question directly
      if (qScore.question) {
        const directText = qScore.question.text || qScore.question.label || qScore.question.title;
        if (directText) {
          return directText;
        }
      }
      
      // Strategy 2: Try lookup with all possible IDs
      const idsToTry = [
        qScore.questionId,
        qScore.questionContextId,
        safeGet(qScore, 'question.id'),
        safeGet(qScore, 'question.contextId'),
        safeGet(qScore, 'question.questionId'),
        safeGet(qScore, 'question.questionContextId'),
        safeGet(qScore, 'id')
      ].filter(Boolean);
      
      for (const id of idsToTry) {
        const text = lookup.questionText.get(id);
        if (text) {
          return text;
        }
      }
      
      // Strategy 3: Try to find by scanning all question objects for partial matches
      if (idsToTry.length > 0) {
        const allQuestionIds = Array.from(lookup.questionText.keys());
        for (const questionId of allQuestionIds) {
          // Check for partial matches (sometimes IDs are truncated)
          for (const searchId of idsToTry) {
            if (questionId.includes(searchId) || searchId.includes(questionId)) {
              const text = lookup.questionText.get(questionId);
              if (text) return text;
            }
          }
        }
      }
      
      // Strategy 4: Try the qScore itself
      const qScoreText = qScore.text || qScore.label || qScore.title;
      if (qScoreText) {
        return qScoreText;
      }
      
      // Strategy 5: Try to extract from answer options if score matches
      const allQuestionObjs = Array.from(lookup.questionObj.values());
      for (const questionObj of allQuestionObjs) {
        if (questionObj.answerOptions && qScore.score !== undefined) {
          const matchingOption = questionObj.answerOptions.find(opt => 
            approx(opt.value, qScore.score) || 
            (opt.value === 0 && qScore.score === 0)
          );
          if (matchingOption) {
            return questionObj.text || questionObj.label || questionObj.title || 'Question';
          }
        }
      }
      
      // Last resort: Show ID or generic text
      if (idsToTry[0]) {
        // Check if ID might actually be the question text (some systems store text as ID)
        const firstId = idsToTry[0];
        if (firstId.length < 100 && !firstId.includes('-') && !firstId.match(/^[a-f0-9]{8}-/i)) {
          return firstId;
        }
        return `Question (${firstId.substring(0, Math.min(8, firstId.length))}...)`;
      }
      
      return 'Question';
    }

    function resolveAnswerTextWithLookup(lookup, qScore) {
      // Try to get answer text from lookup
      const ids = new Set();
      
      // Collect ALL possible answer IDs
      (qScore.selectedAnswerIds || []).forEach(x => ids.add(x));
      (qScore.selectedAnswerOptionIds || []).forEach(x => ids.add(x));
      if (qScore.selectedAnswerId) ids.add(qScore.selectedAnswerId);
      if (qScore.answerOptionId) ids.add(qScore.answerOptionId);
      if (qScore.answerId) ids.add(qScore.answerId);
      
      const a = qScore.answer || {};
      [a.id, a.contextId, a.answerId, a.answerOptionId].filter(Boolean).forEach(x => ids.add(x));
      
      (qScore.answers || []).forEach(ans => { 
        [ans.id, ans.contextId, ans.answerId, ans.answerOptionId].filter(Boolean).forEach(x => ids.add(x)); 
      });
      
      const texts = [];
      Array.from(ids).forEach(id => { 
        const t = lookup.answerText.get(id); 
        if (t) texts.push(t); 
      });
      
      if (texts.length) return texts.join(', ');
      
      // If no answer text found, try to match score to answer options
      const qIds = [ qScore.questionId, qScore.questionContextId, safeGet(qScore, 'question.id'), safeGet(qScore, 'question.contextId') ].filter(Boolean);
      const q = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
      
      if (q && Array.isArray(q.answerOptions) && q.answerOptions.length) {
        const s = Number(qScore.score);
        const match = q.answerOptions.find(o => 
          approx(s, o.value) || 
          approx(s / 100, o.value) || 
          approx(s, o.value * 100) || 
          (o.value === 0 && s === 0) 
        );
        if (match) { 
          return match.text || match.label || String(match.value || ''); 
        }
        if (qScore.score !== null && qScore.score !== undefined) { 
          return `Score: ${qScore.score}`; 
        }
      }
      
      // Fallbacks
      if (qScore.freeTextAnswer) return String(qScore.freeTextAnswer);
      if (qScore.numericAnswer !== undefined && qScore.numericAnswer !== null) return String(qScore.numericAnswer);
      if (safeGet(qScore, 'answer.text')) return qScore.answer.text;
      if (qScore.score !== null && qScore.score !== undefined) { return `Score: ${qScore.score}`; }
      
      return 'No answer';
    }

    // ===== NEW: Month Comparison Function =====
    async function renderMonthComparison() {
      const comparisonContainer = document.getElementById('monthComparison');
      const comparisonGrid = document.getElementById('comparisonGrid');
      
      if (!state.analyticsEvals || state.analyticsEvals.length === 0) {
        comparisonContainer.style.display = 'none';
        return;
      }
      
      // Group evaluations by month
      const evalsByMonth = new Map();
      
      state.analyticsEvals.forEach(e => {
        const date = new Date(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        const monthLabel = new Date(date.getFullYear(), date.getMonth(), 1).toLocaleDateString('en-GB', { month: 'short', year: 'numeric' });
        
        if (!evalsByMonth.has(monthKey)) {
          evalsByMonth.set(monthKey, {
            label: monthLabel,
            evals: [],
            totalScore: 0,
            scoredCount: 0,
            criticalMarks: 0,
            fatalMarks: 0,
            passCount: 0,
            totalCount: 0
          });
        }
        
        const monthData = evalsByMonth.get(monthKey);
        monthData.evals.push(e);
        monthData.totalCount++;
        
        const score = getEvalPercent(e);
        if (score != null && isFinite(score)) {
          monthData.totalScore += score;
          monthData.scoredCount++;
          
          const {pass} = getPassSettings();
          if (score >= pass) {
            monthData.passCount++;
          }
        }
        
        // Count critical/fatal marks
        const qGroups = safeGet(e, 'answers.questionGroupScores') || [];
        qGroups.forEach(g => {
          (g.questionScores || []).forEach(q => {
            const qIds = [q.questionId, q.questionContextId, safeGet(q, 'question.id'), safeGet(q, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => state.combinedLookupCache.get(`${safeGet(e, 'evaluationForm.id') || 'no-pub'}|${safeGet(e, 'form.id') || 'no-form'}|${safeGet(e, 'form.versionId') || 'no-ver'}`)?.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(q, questionObj);
            if (isFatal) monthData.fatalMarks++;
            if (isCritical) monthData.criticalMarks++;
          });
        });
      });
      
      // Get two most recent months
      const sortedMonths = Array.from(evalsByMonth.keys()).sort().reverse();
      if (sortedMonths.length < 2) {
        comparisonContainer.style.display = 'none';
        return;
      }
      
      const recentMonthKey = sortedMonths[0];
      const previousMonthKey = sortedMonths[1];
      
      const recentMonth = evalsByMonth.get(recentMonthKey);
      const previousMonth = evalsByMonth.get(previousMonthKey);
      
      // Calculate metrics
      const recentAvg = recentMonth.scoredCount > 0 ? recentMonth.totalScore / recentMonth.scoredCount : 0;
      const previousAvg = previousMonth.scoredCount > 0 ? previousMonth.totalScore / previousMonth.scoredCount : 0;
      const avgChange = recentAvg - previousAvg;
      
      const recentPassRate = recentMonth.totalCount > 0 ? (recentMonth.passCount / recentMonth.totalCount) * 100 : 0;
      const previousPassRate = previousMonth.totalCount > 0 ? (previousMonth.passCount / previousMonth.totalCount) * 100 : 0;
      const passRateChange = recentPassRate - previousPassRate;
      
      const evalsChange = ((recentMonth.totalCount - previousMonth.totalCount) / previousMonth.totalCount) * 100;
      
      const criticalChange = ((recentMonth.criticalMarks - previousMonth.criticalMarks) / (previousMonth.criticalMarks || 1)) * 100;
      const fatalChange = ((recentMonth.fatalMarks - previousMonth.fatalMarks) / (previousMonth.fatalMarks || 1)) * 100;
      
      // Render comparison
      comparisonGrid.innerHTML = `
        <div class="comparison-item">
          <div class="label">Average Score</div>
          <div class="value">${pct(recentAvg, 1)}</div>
          <div class="change ${avgChange > 0 ? 'positive' : avgChange < 0 ? 'negative' : 'neutral'}">
            ${avgChange > 0 ? 'â†‘' : avgChange < 0 ? 'â†“' : 'â†’'} ${pct(Math.abs(avgChange), 1)}
          </div>
          <div class="comparison-note">${previousMonth.label}: ${pct(previousAvg, 1)}</div>
        </div>
        <div class="comparison-item">
          <div class="label">Pass Rate</div>
          <div class="value">${pct(recentPassRate, 1)}</div>
          <div class="change ${passRateChange > 0 ? 'positive' : passRateChange < 0 ? 'negative' : 'neutral'}">
            ${passRateChange > 0 ? 'â†‘' : passRateChange < 0 ? 'â†“' : 'â†’'} ${pct(Math.abs(passRateChange), 1)}
          </div>
          <div class="comparison-note">${previousMonth.label}: ${pct(previousPassRate, 1)}</div>
        </div>
        <div class="comparison-item">
          <div class="label">Evaluations</div>
          <div class="value">${recentMonth.totalCount}</div>
          <div class="change ${evalsChange > 0 ? 'positive' : evalsChange < 0 ? 'negative' : 'neutral'}">
            ${evalsChange > 0 ? 'â†‘' : evalsChange < 0 ? 'â†“' : 'â†’'} ${fmt(Math.abs(evalsChange), 1)}%
          </div>
          <div class="comparison-note">${previousMonth.label}: ${previousMonth.totalCount}</div>
        </div>
        <div class="comparison-item">
          <div class="label">Critical Marks</div>
          <div class="value">${recentMonth.criticalMarks}</div>
          <div class="change ${criticalChange < 0 ? 'positive' : criticalChange > 0 ? 'negative' : 'neutral'}">
            ${criticalChange < 0 ? 'â†“' : criticalChange > 0 ? 'â†‘' : 'â†’'} ${fmt(Math.abs(criticalChange), 1)}%
          </div>
          <div class="comparison-note">${previousMonth.label}: ${previousMonth.criticalMarks}</div>
        </div>
        <div class="comparison-item">
          <div class="label">Fatal Marks</div>
          <div class="value">${recentMonth.fatalMarks}</div>
          <div class="change ${fatalChange < 0 ? 'positive' : fatalChange > 0 ? 'negative' : 'neutral'}">
            ${fatalChange < 0 ? 'â†“' : fatalChange > 0 ? 'â†‘' : 'â†’'} ${fmt(Math.abs(fatalChange), 1)}%
          </div>
          <div class="comparison-note">${previousMonth.label}: ${previousMonth.fatalMarks}</div>
        </div>
      `;
      
      comparisonContainer.style.display = 'block';
    }

    // ===== Renderers =====
    function renderAll(){ 
      renderOverview(); 
      // FIX 5: Don't automatically render analytics/trends on initial load
      renderDetails(); 
      renderCritical(); 
    }
    
    function resolveUserName(id){ 
      const u=state.users.find(x=>x.id===id); 
      return u?u.name:(id||'(unknown)'); 
    }
    
    function getEvalPercent(e){
      const p=e.totalScore || e.totalPercent || safeGet(e,'scoring.totalPercent') || safeGet(e,'oTotalPercent') || safeGet(e,'answers.totalScore');
      if(p==null) return null; 
      return p<=1 ? p*100 : p;
    }

    function renderOverview(){
      const evals=state.evals;
      const byAgent=new Map();
      evals.forEach(e=>{
        const a=safeGet(e,'agent.id') || e.agentUserId || e.userId || '(unknown)';
        const p=getEvalPercent(e);
        if(!byAgent.has(a)) byAgent.set(a,{count:0,sum:0});
        const o=byAgent.get(a); o.count++; if(p!=null && isFinite(p)) o.sum+=Number(p);
      });
      const rows=[]; let total=0;
      for(const [aid,{count,sum}] of byAgent.entries()){ rows.push({agent:resolveUserName(aid),count,avg:count?(sum/count):null}); total+=count; }
      rows.sort((a,b)=>a.agent.localeCompare(b.agent));
      const overallAvg=(rows.length && total)?(rows.reduce((s,r)=>s+(r.avg||0),0)/rows.length):null;

      document.getElementById('overviewKPIs').innerHTML=`
        <div class="kpi"><div class="label">Date Range</div><div class="value">${document.getElementById('date-range-value').textContent}</div></div>
        <div class="kpi"><div class="label">Evaluations</div><div class="value">${evals.length}</div></div>
        <div class="kpi"><div class="label">Agents</div><div class="value">${rows.length}</div></div>
        <div class="kpi"><div class="label">Average Score (Agent Avg)</div><div class="value">${overallAvg==null?'-':pct(overallAvg,1)}</div></div>`;
      const tbl=document.getElementById('agentSummaryTable');
      tbl.innerHTML = rows.length
        ? `<thead><tr><th>Agent</th><th>Evaluations</th><th>Average Score</th></tr></thead>
           <tbody>${rows.map(r=>`<tr><td>${r.agent}</td><td>${r.count}</td><td>${r.avg==null?'-':pct(r.avg,1)}</td></tr>`).join('')}</tbody>`
        : '<tr><td colspan="3" class="muted">No evaluation data available for the selected criteria.</td></tr>';
    }

    function getAnalyticsSet(){ 
      return (state.analyticsEvals && state.analyticsRange) ? state.analyticsEvals : state.evals; 
    }
    
    function getTrendsSet(){ 
      return (state.trendsEvals && state.trendsRange) ? state.trendsEvals : state.evals; 
    }
    
    function guessMediaType(e){ 
      return standardiseMedia(safeGet(e,'mediaType') || safeGet(e,'conversation.mediaType') || 'Unknown'); 
    }
    
    function buildDays(start,end){ 
      const out=[]; 
      for(let d=new Date(start); d<=end; d.setUTCDate(d.getUTCDate()+1)){ 
        out.push(new Date(d)); 
      } 
      return out; 
    }

    // ===== UPDATED ANALYTICS RENDERER WITH PROPER CHART.JS VISUALS =====
    async function renderAnalytics(){
      const raw = getAnalyticsSet();
      
      // Check if charts should be rendered
      if(!raw || !raw.length){
        document.getElementById('analyticsKPIs').innerHTML='<div class="muted" style="padding:20px;text-align:center">No analytics data loaded. Use "Load Range" button to load data.</div>';
        document.getElementById('mediaTable').innerHTML='<tr><td class="muted">No data loaded yet.</td></tr>';
        document.getElementById('repeatFailsTable').innerHTML='';
        document.getElementById('agentInsights').innerHTML='';
        document.getElementById('trendTable').innerHTML='';
        document.getElementById('topAgentsTable').innerHTML='';
        document.getElementById('bottomAgentsTable').innerHTML='';
        
        // Clear any existing charts properly WITHOUT removing the canvas elements
        ['mediaTypeChart', 'agentTrendChart', 'scoreDistributionChart', 'trendsChart'].forEach(id => {
          const canvas = document.getElementById(id);
          if (canvas) {
            // FIX 6: Check if canvas exists before trying to get context
            const ctx = canvas.getContext('2d');
            if (ctx) {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            // Destroy existing Chart.js instances
            if (id === 'mediaTypeChart' && window.mediaTypeChartInstance) {
              try {
                window.mediaTypeChartInstance.destroy();
              } catch (e) {
                console.warn('Error destroying mediaTypeChart:', e);
              }
              window.mediaTypeChartInstance = null;
            }
            if (id === 'agentTrendChart' && window.agentTrendChartInstance) {
              try {
                window.agentTrendChartInstance.destroy();
              } catch (e) {
                console.warn('Error destroying agentTrendChart:', e);
              }
              window.agentTrendChartInstance = null;
            }
            if (id === 'scoreDistributionChart' && window.scoreDistributionChartInstance) {
              try {
                window.scoreDistributionChartInstance.destroy();
              } catch (e) {
                console.warn('Error destroying scoreDistributionChart:', e);
              }
              window.scoreDistributionChartInstance = null;
            }
            if (id === 'trendsChart' && window.trendsChartInstance) {
              try {
                window.trendsChartInstance.destroy();
              } catch (e) {
                console.warn('Error destroying trendsChart:', e);
              }
              window.trendsChartInstance = null;
            }
          }
        });
        
        // Display "no data" message on the charts WITHOUT replacing canvas elements
        const mediaChartContainer = document.querySelector('.analytics-chart-container');
        if (mediaChartContainer) {
          // Create a placeholder div that will sit on top of the canvas
          let placeholder = mediaChartContainer.querySelector('.chart-placeholder');
          if (!placeholder) {
            placeholder = document.createElement('div');
            placeholder.className = 'chart-placeholder';
            placeholder.style.cssText = 'position:absolute; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:rgba(248,249,250,0.9); z-index:5;';
            mediaChartContainer.appendChild(placeholder);
          }
          placeholder.innerHTML = `
            <div style="text-align:center;padding:20px;">
              <div style="font-size:14px;margin-bottom:8px;">ðŸ“Š</div>
              <div style="font-size:12px;">No data available</div>
              <div style="font-size:11px;margin-top:4px;">Load analytics data first</div>
            </div>
          `;
          placeholder.style.display = 'flex';
        }
        
        // Hide month comparison
        document.getElementById('monthComparison').style.display = 'none';
        
        return;
      }

      // Remove placeholder messages if they exist
      document.querySelectorAll('.chart-placeholder').forEach(placeholder => {
        placeholder.style.display = 'none';
      });

      const teamFilter = dropdowns.analyticsTeams.getSelectedValues();
      let allowedAgents = null;
      if(teamFilter.length){ 
        allowedAgents = new Set(await agentsForTeams(teamFilter)); 
      }
      const evals = allowedAgents ? raw.filter(e => allowedAgents.has(safeGet(e,'agent.id')||e.agentUserId)) : raw;

      const start = state.analyticsRange?.start || state.monthStart;
      const end   = state.analyticsRange?.end   || state.monthEnd;
      
      // Calculate KPIs
      let withFatal=0, withCritical=0, totalCriticalMarks=0, totalFatalMarks=0;
      let sumScores=0, scored=0;
      for (const e of evals) {
        const qgs = safeGet(e, 'answers.questionGroupScores') || [];
        let evalHasFatal = false, evalHasCritical = false;
        for (const g of qgs) {
          for (const q of (g.questionScores || [])) {
            const lookup = await getCombinedLookupForEval(e);
            const qIds = [q.questionId, q.questionContextId, safeGet(q, 'question.id'), safeGet(q, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(q, questionObj);
            if (isFatal) { evalHasFatal = true; totalFatalMarks++; }
            if (isCritical) { evalHasCritical = true; totalCriticalMarks++; }
          }
        }
        if (evalHasFatal) withFatal++;
        if (evalHasCritical) withCritical++;
        const p=getEvalPercent(e); if(p!=null && isFinite(p)){ sumScores+=Number(p); scored++; }
      }
      const avgOverall = scored? (sumScores/scored): null;
      const passRate = evals.length? ((evals.length - Math.max(withFatal, withCritical))/evals.length): null;

      document.getElementById('analyticsKPIs').innerHTML = `
        <div class="kpi"><div class="label">Evaluations Completed</div><div class="value">${evals.length}</div></div>
        <div class="kpi"><div class="label">Avg Score</div><div class="value">${avgOverall==null?'-':pct(avgOverall,1)}</div></div>
        <div class="kpi"><div class="label">Critical Questions Scored</div><div class="value">${totalCriticalMarks}</div></div>
        <div class="kpi"><div class="label">Critical Markdowns</div><div class="value">${withCritical}</div></div>
        <div class="kpi"><div class="label">Fatal Evaluations</div><div class="value">${withFatal}</div></div>
        <div class="kpi"><div class="label">Fatal Marks</div><div class="value">${totalFatalMarks}</div></div>
        <div class="kpi"><div class="label">Pass Rate</div><div class="value">${passRate==null?'-':pct(passRate*80,1)}</div></div>
      `;

      const {pass, band} = getPassSettings();
      
      // Data for charts
      const mediaTypeData = { Voice: { pass: 0, amber: 0, fail: 0 }, 
                             Email: { pass: 0, amber: 0, fail: 0 }, 
                             Message: { pass: 0, amber: 0, fail: 0 }, 
                             Social: { pass: 0, amber: 0, fail: 0 }, 
                             Other: { pass: 0, amber: 0, fail: 0 } };
      
      const agentTrendData = new Map(); // agent -> {dates: [], scores: []}
      const scoreDistribution = Array(10).fill(0); // 0-10, 11-20, ..., 91-100
      
      const byAgent=new Map(); // agent -> media -> {count,sum,scored}
      evals.forEach(e=>{
        const aid=safeGet(e,'agent.id')||e.agentUserId||'(unknown)';
        const name=resolveUserName(aid);
        const mt=guessMediaType(e);
        const p=getEvalPercent(e);
        
        // Media type chart data
        if (p != null && isFinite(p)) {
          if (p >= pass) mediaTypeData[mt].pass++;
          else if (p >= pass - band) mediaTypeData[mt].amber++;
          else mediaTypeData[mt].fail++;
        }
        
        // Agent trend data
        if (!agentTrendData.has(name)) {
          agentTrendData.set(name, { dates: [], scores: [] });
        }
        const date = new Date(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        agentTrendData.get(name).dates.push(date);
        agentTrendData.get(name).scores.push(p || 0);
        
        // Score distribution
        if (p != null && isFinite(p)) {
          const bucket = Math.floor(p / 10);
          const idx = bucket === 10 ? 9 : bucket;
          scoreDistribution[idx]++;
        }
        
        // Existing media table data
        if(!byAgent.has(aid)) byAgent.set(aid,{name,map:new Map()});
        const m=byAgent.get(aid).map;
        if(!m.has(mt)) m.set(mt,{count:0,sum:0,scored:0});
        const o=m.get(mt);
        o.count++;
        if(p!=null&&isFinite(p)){ o.sum+=Number(p); o.scored++; }
      });

      // 1. Media Type Chart (Stacked Bar)
      try {
        const mediaTypeCanvas = document.getElementById('mediaTypeChart');
        // FIX 7: Check if canvas exists and get context safely
        if (!mediaTypeCanvas) {
          console.warn('mediaTypeChart canvas not found');
        } else {
          const mediaTypeCtx = mediaTypeCanvas.getContext('2d');
          if (!mediaTypeCtx) {
            console.warn('Could not get 2d context for mediaTypeChart');
          } else {
            // Destroy existing chart instance
            if (window.mediaTypeChartInstance) {
              try {
                window.mediaTypeChartInstance.destroy();
              } catch (e) {
                console.warn('Error destroying existing mediaTypeChart:', e);
              }
              window.mediaTypeChartInstance = null;
            }
            
            const mediaTypes = ['Voice', 'Email', 'Message', 'Social', 'Other'];
            window.mediaTypeChartInstance = new Chart(mediaTypeCtx, {
              type: 'bar',
              data: {
                labels: mediaTypes,
                datasets: [
                  {
                    label: 'Pass',
                    data: mediaTypes.map(mt => mediaTypeData[mt].pass),
                    backgroundColor: COLORS.OK,
                    borderColor: COLORS.OK,
                    borderWidth: 1
                  },
                  {
                    label: 'Amber',
                    data: mediaTypes.map(mt => mediaTypeData[mt].amber),
                    backgroundColor: COLORS.WARN,
                    borderColor: COLORS.WARN,
                    borderWidth: 1
                  },
                  {
                    label: 'Fail',
                    data: mediaTypes.map(mt => mediaTypeData[mt].fail),
                    backgroundColor: COLORS.BAD,
                    borderColor: COLORS.BAD,
                    borderWidth: 1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    stacked: true,
                    title: {
                      display: true,
                      text: 'Media Type'
                    }
                  },
                  y: {
                    stacked: true,
                    beginAtZero: true,
                    title: {
                      display: true,
                      text: 'Number of Evaluations'
                    }
                  }
                },
                plugins: {
                  tooltip: {
                    mode: 'index',
                    intersect: false
                  },
                  legend: {
                    position: 'top'
                  }
                }
              }
            });
          }
        }
      } catch (chartError) {
        console.error('Error creating mediaTypeChart:', chartError);
      }

      // 2. Agent Trend Chart (Line chart for top 5 agents)
      try {
        const agentTrendCanvas = document.getElementById('agentTrendChart');
        if (!agentTrendCanvas) {
          console.warn('agentTrendChart canvas not found');
        } else {
          const agentTrendCtx = agentTrendCanvas.getContext('2d');
          if (!agentTrendCtx) {
            console.warn('Could not get 2d context for agentTrendChart');
          } else {
            // Destroy existing chart instance
            if (window.agentTrendChartInstance) {
              try {
                window.agentTrendChartInstance.destroy();
              } catch (e) {
                console.warn('Error destroying existing agentTrendChart:', e);
              }
              window.agentTrendChartInstance = null;
            }
            
            // Get top 5 agents by number of evaluations
            const topAgents = Array.from(agentTrendData.entries())
              .sort((a, b) => b[1].scores.length - a[1].scores.length)
              .slice(0, 5);
            
            // Prepare data for line chart
            const allDates = Array.from(new Set(topAgents.flatMap(([name, data]) => 
              data.dates.map(d => d.toISOString().split('T')[0])
            ))).sort();
            
            const datasets = topAgents.map(([name, data], idx) => {
              // Create map of date to average score for that day
              const dateScoreMap = new Map();
              data.dates.forEach((date, i) => {
                const dateStr = date.toISOString().split('T')[0];
                const score = data.scores[i];
                if (!dateScoreMap.has(dateStr)) {
                  dateScoreMap.set(dateStr, []);
                }
                dateScoreMap.get(dateStr).push(score);
              });
              
              // Calculate average for each date
              const scoresByDate = allDates.map(date => {
                const scores = dateScoreMap.get(date);
                return scores && scores.length > 0 
                  ? scores.reduce((sum, s) => sum + s, 0) / scores.length 
                  : null;
              });
              
              // Generate distinct color
              const hue = (idx * 360 / topAgents.length) % 360;
              const color = `hsl(${hue}, 70%, 50%)`;
              
              return {
                label: name,
                data: scoresByDate,
                borderColor: color,
                backgroundColor: color + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.4
              };
            });
            
            window.agentTrendChartInstance = new Chart(agentTrendCtx, {
              type: 'line',
              data: {
                labels: allDates.map(d => new Date(d).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })),
                datasets: datasets
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: {
                      display: true,
                      text: 'Date'
                    }
                  },
                  y: {
                    beginAtZero: false,
                    min: 0,
                    max: 100,
                    title: {
                      display: true,
                      text: 'Score (%)'
                    },
                    ticks: {
                      callback: function(value) {
                        return value + '%';
                      }
                    }
                  }
                },
                plugins: {
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        return `${context.dataset.label}: ${context.parsed.y ? pct(context.parsed.y, 1) : 'N/A'}`;
                      }
                    }
                  },
                  legend: {
                    position: 'top'
                  }
                }
              }
            });
          }
        }
      } catch (chartError) {
        console.error('Error creating agentTrendChart:', chartError);
      }

      // 3. Score Distribution Chart (Histogram)
      try {
        const scoreDistCanvas = document.getElementById('scoreDistributionChart');
        if (!scoreDistCanvas) {
          console.warn('scoreDistributionChart canvas not found');
        } else {
          const scoreDistCtx = scoreDistCanvas.getContext('2d');
          if (!scoreDistCtx) {
            console.warn('Could not get 2d context for scoreDistributionChart');
          } else {
            // Destroy existing chart instance
            if (window.scoreDistributionChartInstance) {
              try {
                window.scoreDistributionChartInstance.destroy();
              } catch (e) {
                console.warn('Error destroying existing scoreDistributionChart:', e);
              }
              window.scoreDistributionChartInstance = null;
            }
            
            const scoreLabels = ['0-10%', '11-20%', '21-30%', '31-40%', '41-50%', '51-60%', '61-70%', '71-80%', '81-90%', '91-100%'];
            
            // Color bars based on score ranges
            const backgroundColors = scoreLabels.map((label, idx) => {
              const minScore = idx * 10;
              if (minScore >= pass) return COLORS.OK;
              if (minScore >= pass - band) return COLORS.WARN;
              return COLORS.BAD;
            });
            
            window.scoreDistributionChartInstance = new Chart(scoreDistCtx, {
              type: 'bar',
              data: {
                labels: scoreLabels,
                datasets: [{
                  label: 'Number of Evaluations',
                  data: scoreDistribution,
                  backgroundColor: backgroundColors,
                  borderColor: backgroundColors.map(c => c.replace('0.8', '1')),
                  borderWidth: 1
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: {
                      display: true,
                      text: 'Score Range'
                    }
                  },
                  y: {
                    beginAtZero: true,
                    title: {
                      display: true,
                      text: 'Number of Evaluations'
                    }
                  }
                },
                plugins: {
                  legend: {
                    display: false
                  },
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        return `${context.parsed.y} evaluation${context.parsed.y !== 1 ? 's' : ''}`;
                      }
                    }
                  }
                }
              }
            });
          }
        }
      } catch (chartError) {
        console.error('Error creating scoreDistributionChart:', chartError);
      }

      // Build media table (agent Ã— media) - KEEPING EXISTING TABLE
      const mediaTypesTable=['Voice','Email','Message','Social','Other'];
      const mediaHead='<thead><tr><th>Agent</th>'+mediaTypesTable.map(mt=>`<th>${mt} (avg)</th>`).join('')+'<th>Overall</th><th>Evaluations</th></tr></thead>';
      let mediaRows='';
      const insightData=[];
      
      for(const [aid,{name,map}] of byAgent.entries()){
        const overall={count:0,sum:0,scored:0};
        let fails=0;
        const cells=[];
        mediaTypesTable.forEach(mt=>{
          const o=map.get(mt);
          const avg=o&&o.scored? o.sum/o.scored : null;
          overall.count+=(o?.count||0);
          overall.sum+=(o?.sum||0);
          overall.scored+=(o?.scored||0);
          if(avg!==null && avg<pass-band) fails+=(o?.count||0);
          const col=colourFor(avg,pass,band);
          cells.push(`<td style="color:${col}">${avg==null?'-':pct(avg,1)} ${o?`(${o.count})`:''}</td>`);
        });
        const overallAvg=overall.scored? overall.sum/overall.scored : null;
        const overallCol=colourFor(overallAvg,pass,band);
        mediaRows+=`<tr>
          <td><strong>${name}</strong></td>
          ${cells.join('')}
          <td style="color:${overallCol}"><strong>${overallAvg==null?'-':pct(overallAvg,1)}</strong></td>
          <td>${overall.count}</td>
        </tr>`;
        insightData.push({name,avg:overallAvg,count:overall.count,fails});
      }
      
      document.getElementById('mediaTable').innerHTML=mediaHead+'<tbody>'+mediaRows+'</tbody>';

      // Store insight data for sorting
      window._insightData = insightData;
      renderAgentInsights();

      // Repeat failures table
      const repeatFails = new Map(); // question text -> {formName, agents: Map, count}
      for (const e of evals) {
        const lookup = await getCombinedLookupForEval(e);
        const agentName = resolveUserName(safeGet(e, 'agent.id') || e.agentUserId);
        const qGroups = safeGet(e, 'answers.questionGroupScores') || [];
        qGroups.forEach(g => {
          (g.questionScores || []).forEach(q => {
            const qIds = [q.questionId, q.questionContextId, safeGet(q, 'question.id'), safeGet(q, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(q, questionObj);
            if (isFatal || isCritical) {
              const qText = resolveQuestionTextWithLookup(lookup, q);
              const key = `${lookup.formName}|${qText}`;
              if (!repeatFails.has(key)) {
                repeatFails.set(key, { formName: lookup.formName, qText, agents: new Map(), count: 0 });
              }
              const entry = repeatFails.get(key);
              entry.count++;
              entry.agents.set(agentName, (entry.agents.get(agentName) || 0) + 1);
            }
          });
        });
      }
      
      const repeatFailRows = Array.from(repeatFails.values())
        .sort((a, b) => b.count - a.count)
        .slice(0, 20)
        .map(r => {
          const agentsArr = Array.from(r.agents.entries()).sort((a, b) => b[1] - a[1]);
          const agentsHtml = agentsArr.map(([name, count]) => 
            `<span class="pill">${name} Ã— ${count}</span>`
          ).join(' ');
          
          return `<tr>
            <td>${r.formName}</td>
            <td>${r.qText}</td>
            <td>${r.count}</td>
            <td>${agentsArr.length}</td>
            <td>${agentsHtml}</td>
          </tr>`;
        }).join('');
      
      document.getElementById('repeatFailsTable').innerHTML = repeatFailRows
        ? `<thead><tr><th>Form</th><th>Question</th><th>Total Marks</th><th>Agents</th><th>Agent Breakdown</th></tr></thead><tbody>${repeatFailRows}</tbody>`
        : '<tr><td class="muted">No repeat failures found.</td></tr>';

      // Daily trend table
      const days = buildDays(start, end);
      const dayKeys = days.map(d => dayKeyUTC(d));
      const dayLabels = days.map(d => toUKDate(d));
      
      // Agent trend data for table
      const agentTrendTable = new Map(); // agent -> day -> {count, sum}
      evals.forEach(e => {
        const aid = safeGet(e, 'agent.id') || e.agentUserId;
        const name = resolveUserName(aid);
        const date = new Date(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const day = dayKeyUTC(date);
        const score = getEvalPercent(e);
        
        if (!agentTrendTable.has(name)) {
          agentTrendTable.set(name, new Map());
        }
        const agentMap = agentTrendTable.get(name);
        if (!agentMap.has(day)) {
          agentMap.set(day, { count: 0, sum: 0 });
        }
        const dayData = agentMap.get(day);
        dayData.count++;
        if (score != null && isFinite(score)) {
          dayData.sum += score;
        }
      });
      
      // Build table
      let trendTable = `<table class="frozen-table">
        <thead>
          <tr>
            <th>Agent</th>`;
      
      dayLabels.forEach(label => {
        trendTable += `<th>${label}</th>`;
      });
      
      trendTable += `</tr></thead><tbody>`;
      
      Array.from(agentTrendTable.entries())
        .sort(([aName], [bName]) => aName.localeCompare(bName))
        .forEach(([name, dayMap]) => {
          trendTable += `<tr><td>${name}</td>`;
          
          dayKeys.forEach(day) => {
            const data = dayMap.get(day);
            if (data && data.count > 0) {
              const avg = data.sum / data.count;
              const col = colourFor(avg, pass, band);
              trendTable += `<td style="color:${col};text-align:center" title="${data.count} eval${data.count !== 1 ? 's' : ''}">
                ${pct(avg, 0)}<br><small style="font-size:10px">(${data.count})</small>
              </td>`;
            } else {
              trendTable += '<td style="text-align:center">-</td>';
            }
          });
          
          trendTable += '</tr>';
        });
      
      trendTable += '</tbody></table>';
      document.getElementById('trendTable').innerHTML = trendTable;

      // Top/Bottom agents tables
      const sortedAgents = insightData
        .filter(a => a.count > 0)
        .sort((a, b) => (b.avg || 0) - (a.avg || 0));
      
      const topAgentsTable = sortedAgents.slice(0, 10);
      const bottomAgentsTable = sortedAgents.slice(-10).reverse();
      
      // Top agents table
      let topHtml = '<thead><tr><th>Rank</th><th>Agent</th><th>Avg Score</th><th>Evaluations</th><th>Failures</th></tr></thead><tbody>';
      topAgentsTable.forEach((agent, i) => {
        const col = colourFor(agent.avg, pass, band);
        topHtml += `<tr>
          <td>${i + 1}</td>
          <td>${agent.name}</td>
          <td style="color:${col}">${agent.avg == null ? '-' : pct(agent.avg, 1)}</td>
          <td>${agent.count}</td>
          <td>${agent.fails}</td>
        </tr>`;
      });
      topHtml += '</tbody>';
      document.getElementById('topAgentsTable').innerHTML = topHtml;
      
      // Bottom agents table
      let bottomHtml = '<thead><tr><th>Rank</th><th>Agent</th><th>Avg Score</th><th>Evaluations</th><th>Failures</th></tr></thead><tbody>';
      bottomAgentsTable.forEach((agent, i) => {
        const col = colourFor(agent.avg, pass, band);
        bottomHtml += `<tr>
          <td>${sortedAgents.length - i}</td>
          <td>${agent.name}</td>
          <td style="color:${col}">${agent.avg == null ? '-' : pct(agent.avg, 1)}</td>
          <td>${agent.count}</td>
          <td>${agent.fails}</td>
        </tr>`;
      });
      bottomHtml += '</tbody>';
      document.getElementById('bottomAgentsTable').innerHTML = bottomHtml;
      
      // NEW: Render month comparison
      renderMonthComparison();
    }

    // ===== TRENDS RENDERER (Keep existing) =====
    async function renderTrends() {
      const raw = getTrendsSet();
      const trendsView = document.getElementById('trendsView');
      const trendsNoData = document.getElementById('trendsNoData');
      
      if (!raw || !raw.length) {
        trendsView.style.display = 'none';
        trendsNoData.style.display = 'block';
        document.getElementById('trendsKPIs').innerHTML = '';
        
        // Clear any existing chart
        if (window.trendsChartInstance) {
          try {
            window.trendsChartInstance.destroy();
          } catch (e) {
            console.warn('Error destroying trendsChart:', e);
          }
          window.trendsChartInstance = null;
        }
        
        return;
      }
      
      trendsView.style.display = 'block';
      trendsNoData.style.display = 'none';
      
      const teamFilter = dropdowns.trendTeams.getSelectedValues();
      let allowedAgents = null;
      if (teamFilter.length) {
        allowedAgents = new Set(await agentsForTeams(teamFilter));
      }
      const evals = allowedAgents ? raw.filter(e => allowedAgents.has(safeGet(e, 'agent.id') || e.agentUserId)) : raw;
      
      const { pass, band } = getTrendPassSettings();
      const period = document.getElementById('trendPeriodSelect').value;
      
      // Group evaluations by period
      const periodMap = new Map();
      const agentPeriodMap = new Map(); // agent -> period -> {count, sum, passes, ambers, fails}
      
      evals.forEach(e => {
        const date = new Date(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        let periodKey, periodLabel;
        
        if (period === 'week') {
          periodKey = `${date.getFullYear()}-W${String(getWeekNumber(date)).padStart(2, '0')}`;
          periodLabel = formatWeek(date);
        } else {
          periodKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          periodLabel = new Date(date.getFullYear(), date.getMonth(), 1).toLocaleDateString('en-GB', { month: 'short', year: 'numeric' });
        }
        
        const score = getEvalPercent(e);
        const agentId = safeGet(e, 'agent.id') || e.agentUserId;
        const agentName = resolveUserName(agentId);
        
        // Update period totals
        if (!periodMap.has(periodKey)) {
          periodMap.set(periodKey, {
            label: periodLabel,
            count: 0,
            sum: 0,
            passes: 0,
            ambers: 0,
            fails: 0,
            critical: 0,
            fatal: 0
          });
        }
        const periodData = periodMap.get(periodKey);
        periodData.count++;
        if (score != null && isFinite(score)) {
          periodData.sum += score;
          if (score >= pass) periodData.passes++;
          else if (score >= pass - band) periodData.ambers++;
          else periodData.fails++;
        }
        
        // Check for critical/fatal
        const qGroups = safeGet(e, 'answers.questionGroupScores') || [];
        qGroups.forEach(g => {
          (g.questionScores || []).forEach(q => {
            const qIds = [q.questionId, q.questionContextId, safeGet(q, 'question.id'), safeGet(q, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => state.combinedLookupCache.get(`${safeGet(e, 'evaluationForm.id') || 'no-pub'}|${safeGet(e, 'form.id') || 'no-form'}|${safeGet(e, 'form.versionId') || 'no-ver'}`)?.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(q, questionObj);
            if (isFatal) periodData.fatal++;
            if (isCritical) periodData.critical++;
          });
        });
        
        // Update agent-period data
        if (!agentPeriodMap.has(agentName)) {
          agentPeriodMap.set(agentName, new Map());
        }
        const agentMap = agentPeriodMap.get(agentName);
        if (!agentMap.has(periodKey)) {
          agentMap.set(periodKey, {
            count: 0,
            sum: 0,
            passes: 0,
            ambers: 0,
            fails: 0
          });
        }
        const agentPeriodData = agentMap.get(periodKey);
        agentPeriodData.count++;
        if (score != null && isFinite(score)) {
          agentPeriodData.sum += score;
          if (score >= pass) agentPeriodData.passes++;
          else if (score >= pass - band) agentPeriodData.ambers++;
          else agentPeriodData.fails++;
        }
      });
      
      // Sort periods chronologically
      const sortedPeriods = Array.from(periodMap.keys()).sort();
      const periodData = sortedPeriods.map(key => periodMap.get(key));
      
      // Calculate KPIs
      let totalEvals = 0;
      let totalScore = 0;
      let totalPasses = 0;
      let totalCritical = 0;
      let totalFatal = 0;
      
      periodData.forEach(p => {
        totalEvals += p.count;
        totalScore += p.sum;
        totalPasses += p.passes;
        totalCritical += p.critical;
        totalFatal += p.fatal;
      });
      
      const avgScore = totalEvals > 0 ? totalScore / totalEvals : null;
      const passRate = totalEvals > 0 ? (totalPasses / totalEvals) * 100 : null;
      
      document.getElementById('trendsKPIs').innerHTML = `
        <div class="kpi"><div class="label">Total Evaluations</div><div class="value">${totalEvals}</div></div>
        <div class="kpi"><div class="label">Avg Score</div><div class="value">${avgScore == null ? '-' : pct(avgScore, 1)}</div></div>
        <div class="kpi"><div class="label">Pass Rate</div><div class="value">${passRate == null ? '-' : pct(passRate, 1)}</div></div>
        <div class="kpi"><div class="label">Critical Marks</div><div class="value">${totalCritical}</div></div>
        <div class="kpi"><div class="label">Fatal Marks</div><div class="value">${totalFatal}</div></div>
        <div class="kpi"><div class="label">Periods</div><div class="value">${sortedPeriods.length}</div></div>
      `;
      
      // Update chart title
      document.getElementById('trendsTitle').textContent = 
        period === 'week' ? 'Week over Week Performance' : 'Month over Month Performance';
      
      // Create Chart.js chart
      const canvas = document.getElementById('trendsChart');
      if (!canvas) {
        console.error('trendsChart canvas not found');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Could not get 2d context for trendsChart');
        return;
      }
      
      // Destroy existing chart if it exists
      if (window.trendsChartInstance) {
        try {
          window.trendsChartInstance.destroy();
        } catch (e) {
          console.warn('Error destroying existing trendsChart:', e);
        }
        window.trendsChartInstance = null;
      }
      
      const labels = periodData.map(p => p.label);
      const passData = periodData.map(p => p.passes);
      const amberData = periodData.map(p => p.ambers);
      const failData = periodData.map(p => p.fails);
      
      window.trendsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Passed',
              data: passData,
              backgroundColor: COLORS.OK,
              borderColor: COLORS.OK,
              borderWidth: 1
            },
            {
              label: 'Amber',
              data: amberData,
              backgroundColor: COLORS.WARN,
              borderColor: COLORS.WARN,
              borderWidth: 1
            },
            {
              label: 'Failed',
              data: failData,
              backgroundColor: COLORS.BAD,
              borderColor: COLORS.BAD,
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true,
              title: {
                display: true,
                text: period === 'week' ? 'Week' : 'Month'
              }
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: {
                display: true,
                text: 'Number of Evaluations'
              }
            }
          },
          plugins: {
            tooltip: {
              mode: 'index',
              intersect: false
            },
            legend: {
              position: 'top'
            }
          }
        }
      });
      
      // Calculate trend statistics
      let improvementCount = 0;
      let declineCount = 0;
      let stableCount = 0;
      
      if (periodData.length >= 2) {
        const firstPeriod = periodData[0];
        const lastPeriod = periodData[periodData.length - 1];
        
        const firstAvg = firstPeriod.count > 0 ? firstPeriod.sum / firstPeriod.count : 0;
        const lastAvg = lastPeriod.count > 0 ? lastPeriod.sum / lastPeriod.count : 0;
        const avgChange = lastAvg - firstAvg;
        const percentChange = firstAvg > 0 ? (avgChange / firstAvg) * 100 : 0;
        
        const firstPassRate = firstPeriod.count > 0 ? (firstPeriod.passes / firstPeriod.count) * 100 : 0;
        const lastPassRate = lastPeriod.count > 0 ? (lastPeriod.passes / lastPeriod.count) * 100 : 0;
        const passRateChange = lastPassRate - firstPassRate;
        
        document.getElementById('trendStats').innerHTML = `
          <div class="trend-stat ${avgChange > 0 ? 'good' : avgChange < 0 ? 'bad' : 'warning'}">
            <div class="label">Avg Score Change</div>
            <div class="value">${avgChange > 0 ? '+' : ''}${pct(avgChange, 1)}</div>
            <div class="label">${firstPeriod.label} â†’ ${lastPeriod.label}</div>
          </div>
          <div class="trend-stat ${passRateChange > 0 ? 'good' : passRateChange < 0 ? 'bad' : 'warning'}">
            <div class="label">Pass Rate Change</div>
            <div class="value">${passRateChange > 0 ? '+' : ''}${pct(passRateChange, 1)}</div>
            <div class="label">${firstPeriod.label} â†’ ${lastPeriod.label}</div>
          </div>
          <div class="trend-stat ${percentChange > 5 ? 'good' : percentChange < -5 ? 'bad' : 'warning'}">
            <div class="label">% Change</div>
            <div class="value">${percentChange > 0 ? '+' : ''}${fmt(percentChange, 1)}%</div>
            <div class="label">Overall Change</div>
          </div>
          <div class="trend-stat">
            <div class="label">Critical Marks</div>
            <div class="value">${totalCritical}</div>
            <div class="label">Total</div>
          </div>
          <div class="trend-stat">
            <div class="label">Fatal Marks</div>
            <div class="value">${totalFatal}</div>
            <div class="label">Total</div>
          </div>
        `;
      } else {
        document.getElementById('trendStats').innerHTML = `
          <div class="trend-stat">
            <div class="label">Insufficient Data</div>
            <div class="value">-</div>
            <div class="label">Need at least 2 periods</div>
          </div>
        `;
      }
      
      // Build agent improvement table
      const agentImprovements = [];
      
      Array.from(agentPeriodMap.entries()).forEach(([agentName, periodMap]) => {
        const periods = Array.from(periodMap.keys()).sort();
        if (periods.length >= 2) {
          const firstPeriod = periods[0];
          const lastPeriod = periods[periods.length - 1];
          
          const firstData = periodMap.get(firstPeriod);
          const lastData = periodMap.get(lastPeriod);
          
          const firstAvg = firstData.count > 0 ? firstData.sum / firstData.count : 0;
          const lastAvg = lastData.count > 0 ? lastData.sum / lastData.count : 0;
          
          const firstPassRate = firstData.count > 0 ? (firstData.passes / firstData.count) * 100 : 0;
          const lastPassRate = lastData.count > 0 ? (lastData.passes / lastData.count) * 100 : 0;
          
          const avgChange = lastAvg - firstAvg;
          const passRateChange = lastPassRate - firstPassRate;
          const totalEvals = Array.from(periodMap.values()).reduce((sum, data) => sum + data.count, 0);
          
          agentImprovements.push({
            agentName,
            firstAvg,
            lastAvg,
            avgChange,
            firstPassRate,
            lastPassRate,
            passRateChange,
            totalEvals,
            trend: avgChange > 5 ? 'strong-improvement' : avgChange > 0 ? 'improvement' : avgChange < -5 ? 'decline' : 'stable'
          });
        }
      });
      
      // Sort by improvement
      agentImprovements.sort((a, b) => b.avgChange - a.avgChange);
      
      let improvementHtml = '<thead><tr><th>Agent</th><th>First Avg</th><th>Last Avg</th><th>Change</th><th>First Pass Rate</th><th>Last Pass Rate</th><th>Pass Rate Change</th><th>Total Evals</th><th>Trend</th></tr></thead><tbody>';
      
      agentImprovements.forEach(agent => {
        const trendIcon = agent.trend === 'strong-improvement' ? 'ðŸ“ˆâ†‘' :
                         agent.trend === 'improvement' ? 'ðŸ“ˆ' :
                         agent.trend === 'decline' ? 'ðŸ“‰' : 'âž¡';
        const trendClass = agent.trend.includes('improvement') ? 'good' :
                          agent.trend === 'decline' ? 'bad' : 'warning';
        
        improvementHtml += `<tr>
          <td>${agent.agentName}</td>
          <td>${pct(agent.firstAvg, 1)}</td>
          <td>${pct(agent.lastAvg, 1)}</td>
          <td class="${trendClass}">${agent.avgChange > 0 ? '+' : ''}${pct(agent.avgChange, 1)}</td>
          <td>${pct(agent.firstPassRate, 1)}</td>
          <td>${pct(agent.lastPassRate, 1)}</td>
          <td class="${trendClass}">${agent.passRateChange > 0 ? '+' : ''}${pct(agent.passRateChange, 1)}</td>
          <td>${agent.totalEvals}</td>
          <td class="${trendClass}">${trendIcon}</td>
        </tr>`;
      });
      
      improvementHtml += '</tbody>';
      document.getElementById('trendImprovementTable').innerHTML = improvementHtml || '<tr><td colspan="9" class="muted">No trend data available for agents.</td></tr>';
    }

    // ===== DETAILS RENDERER =====
    async function applyDetailsFilters() {
      state.detailsAgentFilter = document.getElementById('detailsAgentFilter').value;
      state.detailsScoreFilter = document.getElementById('detailsScoreFilter').value;
      renderDetails();
    }

    async function renderDetails() {
      const c = document.getElementById('detailsContainer');
      if (!state.evals.length) { 
        c.innerHTML = '<div class="muted">No evaluations loaded.</div>'; 
        return; 
      }
      
      c.innerHTML = '<div class="info-message">Loading evaluation details...</div>';

      // Create evaluation data with all needed information
      const evaluationData = await Promise.all(state.evals.map(async (e) => {
        const agent = resolveUserName(safeGet(e, 'agent.id') || e.agentUserId);
        const lookup = await getCombinedLookupForEval(e);
        const formName = lookup.formName;
        const date = new Date(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const when = toDateTime(date);
        const contactInfo = extractContactInfo(e);
        const score = getEvalPercent(e);
        
        // Check for critical/fatal marks - FIXED: changed qgs to qGroups
let hasCritical = false;
let hasFatal = false;
const qGroups = safeGet(e, 'answers.questionGroupScores') || [];
for (const g of qGroups) {
  for (const q of (g.questionScores || [])) {
    const qIds = [q.questionId, q.questionContextId, safeGet(q, 'question.id'), safeGet(q, 'question.contextId')].filter(Boolean);
    const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
    const { isFatal, isCritical } = detectCriticalFatalQuestions(q, questionObj);
    if (isFatal) hasFatal = true;
    if (isCritical) hasCritical = true;
  }     
        return {
          agent,
          formName,
          date,
          when,
          contactInfo,
          score,
          hasCritical,
          hasFatal,
          evalObj: e,
          lookup
        };
      }));

      // Apply filters
      let filteredData = evaluationData;
      
      // Agent filter
      if (state.detailsAgentFilter !== 'all') {
        filteredData = filteredData.filter(d => d.agent === state.detailsAgentFilter);
      }
      
      // Score filter
      if (state.detailsScoreFilter !== 'all') {
        switch(state.detailsScoreFilter) {
          case 'pass':
            filteredData = filteredData.filter(d => d.score >= 85);
            break;
          case 'amber':
            filteredData = filteredData.filter(d => d.score >= 80 && d.score < 85);
            break;
          case 'fail':
            filteredData = filteredData.filter(d => d.score < 80);
            break;
          case 'critical':
            filteredData = filteredData.filter(d => d.hasCritical);
            break;
          case 'fatal':
            filteredData = filteredData.filter(d => d.hasFatal);
            break;
        }
      }

      // Sort the data based on current sort settings
      filteredData.sort((a, b) => {
        let aVal, bVal;
        
        switch(state.detailsSortField) {
          case 'date':
            aVal = a.date.getTime();
            bVal = b.date.getTime();
            break;
          case 'agent':
            aVal = a.agent.toLowerCase();
            bVal = b.agent.toLowerCase();
            break;
          case 'form':
            aVal = a.formName.toLowerCase();
            bVal = b.formName.toLowerCase();
            break;
          case 'score':
            aVal = a.score || 0;
            bVal = b.score || 0;
            break;
          default:
            aVal = a.date.getTime();
            bVal = b.date.getTime();
        }
        
        if (state.detailsSortDirection === 'desc') {
          return bVal - aVal || (bVal < aVal ? 1 : -1);
        } else {
          return aVal - bVal || (aVal < bVal ? -1 : 1);
        }
      });

      // Update agent filter dropdown
      const uniqueAgents = [...new Set(evaluationData.map(d => d.agent))].sort();
      const agentFilter = document.getElementById('detailsAgentFilter');
      agentFilter.innerHTML = '<option value="all">All Agents</option>' + 
        uniqueAgents.map(agent => `<option value="${agent}" ${state.detailsAgentFilter === agent ? 'selected' : ''}>${agent}</option>`).join('');

      // Create sortable header
      const sortArrow = (field) => {
        if (state.detailsSortField === field) {
          return state.detailsSortDirection === 'asc' ? ' â–²' : ' â–¼';
        }
        return '';
      };

      const header = `
        <table class="frozen-table details-table sortable">
          <thead>
            <tr>
              <th class="sort-header" onclick="sortDetails('date')">Time${sortArrow('date')}</th>
              <th class="sort-header" onclick="sortDetails('agent')">Agent${sortArrow('agent')}</th>
              <th class="sort-header" onclick="sortDetails('form')">Form${sortArrow('form')}</th>
              <th class="sort-header" onclick="sortDetails('score')">Score${sortArrow('score')}</th>
              <th>Contact Info</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody>
      `;

      // Create rows
      const rows = await Promise.all(filteredData.map(async (data, index) => {
        const { agent, formName, when, contactInfo, score, evalObj, lookup, hasCritical, hasFatal } = data;
        
        let qRows = '';
        const questionGroups = safeGet(evalObj, 'answers.questionGroupScores') || [];
        
        questionGroups.forEach(group => {
          (group.questionScores || []).forEach(qScore => {
            const questionText = resolveQuestionTextWithLookup(lookup, qScore);
            const answerText = resolveAnswerTextWithLookup(lookup, qScore);
            const ansScore = qScore.score ?? null;
            const qIds = [qScore.questionId, qScore.questionContextId, safeGet(qScore, 'question.id'), safeGet(qScore, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(qScore, questionObj);

            let rowClass = '';
            if (isFatal) rowClass = 'fatal-question';
            else if (isCritical) rowClass = 'critical-warning';

            let allComments = '';
            if (qScore.comments) { allComments += `<div class="comment-bubble"><strong>Evaluator Comments:</strong> ${qScore.comments}</div>`; }
            if (qScore.aiAnswer && qScore.aiAnswer.explanation) { allComments += `<div class="comment-bubble"><strong>AI Analysis:</strong> ${qScore.aiAnswer.explanation}</div>`; }

            qRows += `<tr class="${rowClass}">
              <td>${questionText}</td>
              <td>${answerText}</td>
              <td>${ansScore === null ? '-' : fmt(ansScore, 1)}</td>
              <td>${isFatal ? '<span class="badge badge-fatal">Fatal</span>' : isCritical ? '<span class="badge badge-critical">Critical</span>' : '<span class="badge badge-ok">OK</span>'}</td>
              <td>${allComments}</td>
            </tr>`;
          });
        });

        const questionsTable = qRows 
          ? `<div class="table-container">
               <table class="question-details-table">
                 <thead><tr><th>Question</th><th>Answer</th><th>Score</th><th>Flags</th><th>Comments</th></tr></thead>
                 <tbody>${qRows}</tbody>
               </table>
             </div>`
          : `<div class="muted">No question data available.</div>`;

        // Add critical/fatal indicators to score
        let scoreDisplay = score === null ? '-' : pct(score, 1);
        if (hasFatal) {
          scoreDisplay += ' <span class="badge badge-fatal">Fatal</span>';
        } else if (hasCritical) {
          scoreDisplay += ' <span class="badge badge-critical">Critical</span>';
        }

        return `
          <tr class="expandable-row" onclick="toggleRow(${index})">
            <td>${when}</td>
            <td>${agent}</td>
            <td>${formName}</td>
            <td>${scoreDisplay}</td>
            <td><div class="contact-info">${contactInfo}</div></td>
            <td><span class="expand-icon">â–¶</span> Click to expand</td>
          </tr>
          <tr id="details-row-${index}" class="expandable-content">
            <td colspan="6">
              ${questionsTable}
            </td>
          </tr>
        `;
      }));

      const footer = filteredData.length === 0 
        ? '<tr><td colspan="6" class="muted">No evaluations match the selected filters.</td></tr>'
        : `<tr><td colspan="6" class="muted">Showing ${filteredData.length} of ${evaluationData.length} evaluations</td></tr>`;

      c.innerHTML = header + rows.join('') + footer + '</tbody></table>';
      
      // Initialize all rows as collapsed
      for (let i = 0; i < filteredData.length; i++) {
        const row = document.getElementById(`details-row-${i}`);
        if (row) {
          row.style.display = 'none';
        }
      }
    }

    // ===== CRITICAL RENDERER =====
    async function renderCritical(){
      const tbl=document.getElementById('criticalTable');
      const agentFailuresContainer = document.getElementById('agentFailuresContainer');
      
      if(!state.evals.length){ 
        document.getElementById('criticalSummaryKPIs').innerHTML = '';
        tbl.innerHTML='<tr><td class="muted">No evaluations loaded.</td></tr>'; 
        agentFailuresContainer.innerHTML = '<div class="muted">No evaluations loaded.</div>';
        return; 
      }

      let totalCritical = 0;
      let totalFatal = 0;
      const fatalMap=new Map();  
      const critMap=new Map();
      
      // New data structure for agent failures
      const agentFailures = new Map(); // agent -> Map(question -> {dates: [], type: 'critical'|'fatal'})
      
      function add(map, formName, qText, agentName, date, type){
        const key=formName+'|'+qText;
        if(!map.has(key)) map.set(key,{formName,qText,count:0,agents:new Map()});
        const o=map.get(key); 
        o.count++; 
        o.agents.set(agentName,(o.agents.get(agentName)||0)+1);
        
        // Add to agent failures
        if (!agentFailures.has(agentName)) {
          agentFailures.set(agentName, { 
            failures: new Map(), 
            criticalCount: 0, 
            fatalCount: 0 
          });
        }
        const agentData = agentFailures.get(agentName);
        const questionKey = `${formName}: ${qText}`;
        
        if (!agentData.failures.has(questionKey)) {
          agentData.failures.set(questionKey, { 
            dates: [], 
            type: type,
            count: 0
          });
        }
        const failure = agentData.failures.get(questionKey);
        failure.dates.push(date);
        failure.count++;
        
        // Track counts separately
        if (type === 'fatal') {
          failure.type = 'fatal';
          agentData.fatalCount++;
        } else {
          agentData.criticalCount++;
        }
      }

      for (const e of state.evals){
        const lookup = await getCombinedLookupForEval(e);
        const formName = lookup.formName;
        const agentName = resolveUserName(safeGet(e,'agent.id')||e.agentUserId);
        const date = new Date(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const dateStr = toUKDate(date);
        const qGroups = safeGet(e,'answers.questionGroupScores') || [];
        qGroups.forEach(g=>{
          (g.questionScores||[]).forEach(qs=>{
            const qText = resolveQuestionTextWithLookup(lookup,qs);
            const qIds = [qs.questionId, qs.questionContextId, safeGet(qs, 'question.id'), safeGet(qs, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(qs, questionObj);
            if(isFatal) { 
              add(fatalMap, formName, qText, agentName, dateStr, 'fatal'); 
              totalFatal++; 
            }
            if(isCritical && !isFatal) { 
              add(critMap, formName, qText, agentName, dateStr, 'critical'); 
              totalCritical++; 
            }
          });
        });
      }

      document.getElementById('criticalSummaryKPIs').innerHTML = `
        <div class="critical-kpi critical">
          <div class="number">${totalCritical}</div>
          <div class="label">Total Critical Marks</div>
        </div>
        <div class="critical-kpi fatal">
          <div class="number">${totalFatal}</div>
          <div class="label">Total Fatal Marks</div>
        </div>
        <div class="critical-kpi">
          <div class="number">${totalCritical + totalFatal}</div>
          <div class="label">Total Failures</div>
        </div>
      `;

      // Render agent failures table
      const agentFailureRows = [];
      const agentFailureArray = Array.from(agentFailures.entries())
        .filter(([agent, agentData]) => agentData.failures.size > 0)
        .sort((a, b) => {
          const aTotal = a[1].fatalCount + a[1].criticalCount;
          const bTotal = b[1].fatalCount + b[1].criticalCount;
          return bTotal - aTotal;
        });
      
      agentFailureArray.forEach(([agentName, agentData]) => {
        const failuresMap = agentData.failures;
        const failures = Array.from(failuresMap.entries())
          .sort((a, b) => {
            // Sort by type (fatal first) then by number of occurrences
            if (a[1].type === 'fatal' && b[1].type !== 'fatal') return -1;
            if (a[1].type !== 'fatal' && b[1].type === 'fatal') return 1;
            return b[1].count - a[1].count;
          });
        
        // Calculate totals
        const totalFailures = agentData.fatalCount + agentData.criticalCount;
        const hasFatal = agentData.fatalCount > 0;
        
        const failureItems = failures.map(([question, data]) => {
          const dates = [...new Set(data.dates)].sort().reverse();
          const recentDates = dates.slice(0, 3); // Show only 3 most recent dates
          const datesText = recentDates.join(', ') + (dates.length > 3 ? ` (+${dates.length - 3} more)` : '');
          
          return `
            <tr class="${data.type === 'fatal' ? 'fatal-agent' : ''}">
              <td>${question}</td>
              <td><span class="badge ${data.type === 'fatal' ? 'badge-fatal' : 'badge-critical'}">${data.type === 'fatal' ? 'Fatal' : 'Critical'}</span></td>
              <td>${data.count}</td>
              <td class="failure-dates">${datesText}</td>
            </tr>
          `;
        }).join('');
        
        // Update the header to show both counts
        const headerText = `${agentName} - ${totalFailures} Total (${agentData.fatalCount} Fatal, ${agentData.criticalCount} Critical)`;
        
        agentFailureRows.push(`
          <table class="agent-failure-table">
            <thead>
              <tr class="${hasFatal ? 'fatal-agent' : ''}">
                <th colspan="4">${headerText}</th>
              </tr>
              <tr>
                <th>Question</th>
                <th>Type</th>
                <th>Count</th>
                <th>Dates</th>
              </tr>
            </thead>
            <tbody>
              ${failureItems}
            </tbody>
          </table>
        `);
      });
      
      agentFailuresContainer.innerHTML = agentFailureRows.length 
        ? agentFailureRows.join('')
        : '<div class="muted">No agent failures found for the selected period.</div>';

      const rows = [];
      function rowsFrom(map, type){
        Array.from(map.values())
          .sort((a,b)=>b.count-a.count)
          .forEach(r=>{
            const agentsArr = Array.from(r.agents.entries()).sort((a,b)=>b[1]-a[1]);
            const summaryText = `${agentsArr.length} agent${agentsArr.length!==1?'s':''} / ${r.count} mark${r.count!==1?'s':''}`;
            const agentsHtml = `<details class="agent-list">
                <summary>${summaryText}</summary>
                <div class="agent-pills">
                  ${agentsArr.map(([name,c])=>`<span class="pill">${name} Ã— ${c}</span>`).join('')}
                </div>
              </details>`;
            rows.push(`<tr>
              <td>${r.formName}</td>
              <td>${r.qText}</td>
              <td>${type==='fatal'
                    ? '<span class="badge badge-fatal">Fatal</span>'
                    : '<span class="badge badge-critical">Critical</span>'}</td>
              <td>${r.count}</td>
              <td>${agentsHtml}</td>
            </tr>`;
          });
      }
      rowsFrom(fatalMap,'fatal'); 
      rowsFrom(critMap,'critical');

      tbl.innerHTML = `
        <thead><tr>
          <th>Form</th><th>Question</th><th>Type</th><th>Marks</th><th>Agents</th>
        </tr></thead>
        <tbody>${rows.join('') || `<tr><td colspan="5" class="muted">No critical or fatal marks found for the selected period.</td></tr>`}</tbody>`;
    }
  </script>
</body>
</html>
