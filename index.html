<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>QA Evaluations – Monthly View</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root{ --primary-color:#63AB8F; --secondary-color:#4A8C7D; --border-color:#DEE2E6;
      --light-bg:#F8F9FA; --card-bg:#FFFFFF; --text-color:#2C3E50; --text-light:#6C757D; --pill:#e9f6f0;
      --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    body{font-family:'Aptos','Segoe UI',system-ui,-apple-system,Arial,sans-serif;margin:20px;padding:20px;max-width:1400px;background:var(--light-bg);color:var(--text-color)}
    #logo-container{text-align:center;margin-bottom:20px} #logo{width:300px}
    h1{margin:0 0 16px}
    .card{background:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:24px;margin-top:16px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    label{display:block;font-weight:600;margin-bottom:6px}
    input,select,button,textarea{padding:10px;border:1px solid var(--border-color);border-radius:6px;background:#fff;font-size:14px}
    button{background:var(--primary-color);color:#fff;font-weight:600;cursor:pointer;transition:background .2s}
    button:hover{background:var(--secondary-color)} button:disabled{background:var(--text-light);cursor:not-allowed}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;align-items:start}
    .full-width-btn{width:100%;padding:14px 18px;font-size:16px;margin-top:12px}
    .muted{color:var(--text-light);font-size:12px}
    .section-title{margin:0 0 10px;color:var(--secondary-color)}
    #messageContainer{display:none;margin-top:12px}
    .error-message{color:#b4231a;background:#fee2e2;border:1px solid #fecaca;padding:10px;border-radius:6px}
    .success-message{color:#14532d;background:#dcfce7;border:1px solid #bbf7d0;padding:10px;border-radius:6px}
    .info-message{color:#6b4e16;background:#fff7ed;border:1px solid #ffedd5;padding:10px;border-radius:6px}

    table{width:100%;border-collapse:collapse;margin-top:12px;border:1px solid var(--border-color);border-radius:6px;overflow:hidden}
    th,td{padding:10px 12px;text-align:left;border-bottom:1px solid var(--border-color);vertical-align:top}
    th{background-color:var(--primary-color);color:white;font-weight:600}
    tr:hover{background-color:rgba(99,171,143,.05)}
    .table-container{overflow-x:auto;border:1px solid var(--border-color);border-radius:6px;padding:1px;margin-top:10px}

    /* Frozen column styling for analytics table */
    .frozen-table-container { position: relative; overflow: auto; border: 1px solid var(--border-color); border-radius: 6px; margin-top: 10px; max-height: 600px; -webkit-overflow-scrolling: touch; }
    .frozen-table { border-collapse: separate; border-spacing: 0; width: max-content; min-width: 100%; }
    .frozen-table th, .frozen-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: top; white-space: nowrap; background: var(--card-bg); position: relative; }
    .frozen-table thead th { background-color: var(--primary-color); color: white; font-weight: 600; position: sticky; top: 0; z-index: 10; }
    .frozen-table th:first-child, .frozen-table td:first-child { position: sticky; left: 0; background: var(--card-bg); background-clip: padding-box; z-index: 12; border-right: 2px solid var(--border-color); min-width: 220px; }
    .frozen-table thead th:first-child { z-index: 20; background: var(--primary-color); }
    .frozen-table tr:hover td { background-color: rgba(99,171,143,.05); }
    .frozen-table tr:hover td:first-child { background: rgba(99,171,143,.1); }

    .tab{display:inline-block;padding:12px 20px;margin-right:10px;background:#eee;cursor:pointer;border-radius:6px;font-weight:500}
    .tab.active{background:var(--primary-color);color:white}
    .tab-content{display:none}
    .tab-content.active{display:block}

    .badge{display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;border:1px solid var(--border-color);background:#fff}
    .badge-critical{color:#b4231a;border-color:#fecaca;background:#fee2e2}
    .badge-fatal{color:#fff;background:#b4231a;border-color:#b4231a}
    .badge-ok{color:#14532d;background:#dcfce7;border-color:#bbf7d0}
    details.evaluation{border:1px solid var(--border-color);border-radius:8px;padding:10px;margin:10px 0;background:#fff}
    details.evaluation summary{cursor:pointer;font-weight:600}

    .kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;margin-top:10px}
    .kpi{background:#fff;border:1px solid var(--border-color);border-radius:8px;padding:12px}
    .kpi .label{color:var(--text-light);font-size:12px}
    .kpi .value{font-size:20px;font-weight:700;margin-top:4px}

    .critical-summary-kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-bottom:20px}
    .critical-kpi{background:#fff;border:2px solid var(--border-color);border-radius:12px;padding:20px;text-align:center}
    .critical-kpi.critical{border-color:#f59e0b}
    .critical-kpi.fatal{border-color:#ef4444}
    .critical-kpi .number{font-size:32px;font-weight:800;line-height:1}
    .critical-kpi.critical .number{color:#f59e0b}
    .critical-kpi.fatal .number{color:#ef4444}
    .critical-kpi .label{color:var(--text-light);margin-top:8px;font-size:14px;font-weight:600}

    .checkbox-dropdown{position:relative;min-width:220px;width:100%}
    .cd-trigger{display:flex;align-items:center;justify-content:space-between;border:1px solid var(--border-color);border-radius:6px;background:#fff;padding:10px;cursor:pointer;width:100%;box-sizing:border-box}
    .cd-trigger .label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1}
    .cd-trigger .count{background:var(--pill);border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;color:#2c3e50;flex-shrink:0;margin-left:8px}
    .cd-panel{position:absolute;z-index:1000;margin-top:6px;background:#fff;border:1px solid var(--border-color);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.12);width:100%;max-height:340px;overflow:hidden;display:none;box-sizing:border-box}
    .cd-panel.open{display:block}
    .cd-header{padding:10px;border-bottom:1px solid var(--border-color);display:flex;gap:8px;align-items:center}
    .cd-search{flex:1;border:1px solid var(--border-color);border-radius:6px;padding:8px;width:100%;box-sizing:border-box}
    .cd-actions{display:flex;gap:8px}
    .cd-actions button{background:#eef6f2;color:#2c3e50;border:1px solid var(--border-color);border-radius:6px;padding:8px 10px;cursor:pointer;white-space:nowrap}
    .cd-selectall{padding:8px 12px;border-bottom:1px solid var(--border-color);display:flex;align-items:center;gap:10px}
    .cd-list{max-height:260px;overflow:auto}
    .cd-item{display:flex;align-items:center;gap:10px;padding:8px 12px;border-bottom:1px solid #f1f3f5}
    .cd-item label{display:flex;align-items:center;gap:10px;cursor:pointer;width:100%}
    .cd-footer{padding:8px 12px;background:#fafafa;border-top:1px solid var(--border-color);font-size:12px;color:#6c757d;display:flex;justify-content:space-between}

    .loading-spinner{display:inline-block;width:20px;height:20px;border:2px solid #f3f3f3;border-top:2px solid var(--primary-color);border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}

    .comment-bubble{background:#f8f9fa;border:1px solid #dee2e6;border-radius:12px;padding:8px 12px;margin-top:4px;font-size:12px;color:#6c757d}

    tr.critical-warning{background-color:#fffbeb!important;border-left:4px solid #f59e0b}
    tr.fatal-question{background-color:#fef2f2!important;border-left:4px solid #dc2626}
    tr.critical-warning:hover{background-color:#fef3c7!important}
    tr.fatal-question:hover{background-color:#fecaca!important}

    .details-table th:nth-child(1),
    .details-table td:nth-child(1){ width:32%; min-width:280px }
    .details-table th:nth-child(2),
    .details-table td:nth-child(2){ width:14% }
    .details-table th:nth-child(3),
    .details-table td:nth-child(3){ width:8%; white-space:nowrap }
    .details-table th:nth-child(4),
    .details-table td:nth-child(4){ width:10%; white-space:nowrap }
    .details-table th:nth-child(5),
    .details-table td:nth-child(5){ width:auto }

    .trend-table th:first-child,
    .trend-table td:first-child{ width:220px; min-width:220px; white-space:nowrap }

    .insight-row{display:flex;align-items:center;gap:10px;padding:8px;border-bottom:1px solid #f1f3f5}
    .insight-name{width:200px;flex-shrink:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .insight-bar-wrap{flex:1;background:#f1f3f5;border-radius:999px;overflow:hidden;height:12px}
    .insight-bar{height:100%;background:var(--primary-color)}
    .insight-meta{width:120px;text-align:right;font-size:12px;color:#6c757d}
    .pill{display:inline-block;border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;background:#fff;margin-left:6px}

    .chart-row{display:flex;align-items:center;gap:10px;margin:8px 0}
    .chart-label{width:200px;flex-shrink:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .chart-svg{flex:1;border:1px solid #f1f3f5;border-radius:8px;background:#fafafa}
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .legend .key{display:flex;align-items:center;gap:6px}
    .swatch{width:14px;height:14px;border-radius:3px;border:1px solid #ddd}

    .sortable th{cursor:pointer}
    .sortable th .sort-ind{margin-left:6px;opacity:.8;font-weight:700}

    .stacked-bar-container { position: relative; height: 400px; margin: 20px 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div id="logo-container">
    <img id="logo" src="https://raw.githubusercontent.com/gmcglynn88/Management-Unit-Search/main/Consultinglogo%20(2).png" alt="Company Logo">
  </div>

  <h1>QA Evaluations – Monthly View</h1>

  <div id="authCard" class="card">
    <div id="auth-message" class="info-message">Authenticating with PureCloud...</div>
  </div>

  <div id="appContent" style="display:none;">
    <div id="messageContainer"></div>

    <div class="card">
      <h2 class="section-title">Configuration</h2>
      <div class="controls">
        <div>
          <label for="userDropdown">Agents</label>
          <div id="userDropdown" class="checkbox-dropdown"></div>
        </div>
        <div>
          <label for="teamDropdown">Work Teams</label>
          <div id="teamDropdown" class="checkbox-dropdown"></div>
        </div>
        <div>
          <label for="formDropdown">Evaluation Forms</label>
          <div id="formDropdown" class="checkbox-dropdown"></div>
        </div>
        <div>
          <label for="monthInput">Month</label>
          <input id="monthInput" type="month">
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="loadBtn" class="full-width-btn" disabled>
            <span class="loading-spinner" style="display:none"></span>
            <span class="btn-text">Load Evaluations</span>
          </button>
        </div>
      </div>
    </div>

    <div class="card">
      <div style="margin-bottom:10px;">
        <div id="tabs">
          <div id="overviewTabButton" class="tab active">Overview</div>
          <div id="analyticsTabButton" class="tab">Analytics</div>
          <div id="detailsTabButton" class="tab">Evaluation Details</div>
          <div id="criticalTabButton" class="tab">Critical / Fatal Summary</div>
        </div>
      </div>

      <div id="overviewTab" class="tab-content active">
        <h2 class="section-title">Monthly Overview</h2>
        <div id="overviewKPIs" class="kpis"></div>
        <div class="table-container">
          <table id="agentSummaryTable"></table>
        </div>
      </div>

      <div id="analyticsTab" class="tab-content">
        <h2 class="section-title">Analytics</h2>

        <div class="controls" style="margin-top:8px">
          <div>
            <label for="anaFrom">From (Month)</label>
            <input id="anaFrom" type="month">
          </div>
          <div>
            <label for="anaTo">To (Month)</label>
            <input id="anaTo" type="month">
          </div>
          <div>
            <label for="analyticsTeamDropdown">Filter by Work Team</label>
            <div id="analyticsTeamDropdown" class="checkbox-dropdown"></div>
          </div>
        </div>

        <div class="controls" style="margin-top:8px">
          <div>
            <label for="passTarget">Pass target (%)</label>
            <input id="passTarget" type="number" min="0" max="100" value="85">
          </div>
          <div>
            <label for="amberBand">Amber band (±%)</label>
            <input id="amberBand" type="number" min="0" max="20" value="5">
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="loadAnalyticsBtn" class="full-width-btn">
              <span class="loading-spinner" style="display:none"></span>
              <span class="btn-text">Load Range</span>
            </button>
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="applyAnalyticsFilters" class="full-width-btn">Apply Filters</button>
          </div>
        </div>

        <div id="analyticsKPIs" class="kpis"></div>

        <div class="card" style="padding:16px;margin-top:10px">
          <h3 class="section-title" style="margin:0 0 8px">Daily Trend</h3>
          <div class="stacked-bar-container">
            <canvas id="dailyTrendChart"></canvas>
          </div>
          <div class="legend">
            <div class="key"><span class="swatch" style="background:var(--ok)"></span>Passed</div>
            <div class="key"><span class="swatch" style="background:var(--warn)"></span>Amber</div>
            <div class="key"><span class="swatch" style="background:var(--bad)"></span>Failed</div>
          </div>
        </div>

        <div class="card" style="padding:16px;margin-top:10px">
          <h3 class="section-title" style="margin:0 0 8px">Scores by Media Type per Agent</h3>
          <div id="agentMediaChart"></div>
          <div class="legend">
            <div class="key"><span class="swatch" style="background:var(--ok)"></span>Green: ≥ target</div>
            <div class="key"><span class="swatch" style="background:var(--warn)"></span>Amber: within band</div>
            <div class="key"><span class="swatch" style="background:var(--bad)"></span>Red: below band</div>
          </div>
        </div>

        <div class="table-container">
          <table id="mediaTable" class="sortable"></table>
        </div>
        <div class="table-container">
          <table id="repeatFailsTable" class="sortable"></table>
        </div>

        <div class="card" style="padding:16px;margin-top:16px">
          <div style="display:flex;align-items:center;gap:10px;justify-content:space-between">
            <h3 class="section-title" style="margin:0">Agent Insights</h3>
            <div>
              <label class="muted" style="margin-right:6px">Sort by:</label>
              <select id="insightsSort">
                <option value="avgDesc">Avg score (high→low)</option>
                <option value="avgAsc">Avg score (low→high)</option>
                <option value="failsDesc">Fails (high→low)</option>
                <option value="evalsDesc">Evals (high→low)</option>
              </select>
            </div>
          </div>
          <div id="agentInsights" style="margin-top:8px"></div>
        </div>

        <h3 class="section-title" style="margin-top:18px">Daily Trend by Agent (Selected Period)</h3>
        <div id="trendTable" class="frozen-table-container"></div>

        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-top:16px">
          <div class="table-container">
            <table id="topAgentsTable"></table>
          </div>
          <div class="table-container">
            <table id="bottomAgentsTable"></table>
          </div>
        </div>
      </div>

      <div id="detailsTab" class="tab-content">
        <h2 class="section-title">Evaluation Details (with Question Scores)</h2>
        <div id="detailsContainer"></div>
      </div>

      <div id="criticalTab" class="tab-content">
        <h2 class="section-title">Critical / Kill Question Counts</h2>
        <div id="criticalSummaryKPIs" class="critical-summary-kpis"></div>
        <div class="table-container">
          <table id="criticalTable"></table>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== OAuth Configuration =====
    const clientId = 'fe305808-b368-4547-8af9-325d28d552bb';
    const config = { REGION: 'mypurecloud.ie' };
    const redirectUri = 'https://gmcglynn88.github.io/QualityReporting/'; // must exactly match your OAuth app
    // Hard-coded, pre-encoded OAuth URL
    const oauthUrl = 'https://login.mypurecloud.ie/oauth/authorize?client_id=fe305808-b368-4547-8af9-325d28d552bb&response_type=token&redirect_uri=https%3A%2F%2Fgmcglynn88.github.io%2FQualityReporting%2F&state=qa';

    const state = {
      accessToken: null,
      users: [],
      forms: [],
      formsById: {},
      teams: [],
      teamsById: {},
      teamMembers: new Map(),

      evals: [],
      monthStart: null,
      monthEnd: null,

      analyticsEvals: null,
      analyticsRange: null,

      formDetailsCache: new Map(),
      formLookupCache: new Map(),
      combinedLookupCache: new Map(),
      
      // NEW: Track forms that need to be loaded
      formsToLoad: new Set()
    };

    const dropdowns = { users:null, teams:null, forms:null, analyticsTeams:null };

    // Chart colours resolved from CSS vars (Chart.js can't read CSS vars directly)
    const cssVar = k => getComputedStyle(document.documentElement).getPropertyValue(k).trim();
    let COLORS = { OK: '#22c55e', WARN: '#f59e0b', BAD: '#ef4444', TEXT: '#2C3E50' };
    function resolveColors() {
      COLORS.OK   = cssVar('--ok')          || COLORS.OK;
      COLORS.WARN = cssVar('--warn')        || COLORS.WARN;
      COLORS.BAD  = cssVar('--bad')         || COLORS.BAD;
      COLORS.TEXT = cssVar('--text-color')  || COLORS.TEXT;
    }

    // Throttle + backoff
    let lastApiCall = 0;
    const API_DELAY = 120;                  // ms spacing between calls
    const MAX_CONCURRENT_AGENT_BATCH = 3;

    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    function msg(html,type='info'){
      const box=document.getElementById('messageContainer');
      box.innerHTML=`<div class="${type}-message">${html}</div>`;
      box.style.display='block';
      if(type==='success'){ setTimeout(()=>box.style.display='none',5000); }
    }

    function setLoading(button,isLoading){
      const spinner=button.querySelector('.loading-spinner');
      const text=button.querySelector('.btn-text');
      if(isLoading){ spinner.style.display='inline-block'; text.textContent='Loading...'; button.disabled=true; }
      else{ spinner.style.display='none'; text.textContent = (button.id==='loadAnalyticsBtn'?'Load Range':'Load Evaluations'); button.disabled=false; }
    }

    // ===== Checkbox dropdown =====
    function createCheckboxDropdown(containerId,{placeholder,searchPlaceholder}){
      const root=document.getElementById(containerId); root.innerHTML='';
      const trigger=document.createElement('div'); trigger.className='cd-trigger';
      trigger.innerHTML=`<span class="label">${placeholder}</span><span class="count">0 selected</span>`;
      root.appendChild(trigger);
      const panel=document.createElement('div'); panel.className='cd-panel';
      panel.innerHTML=`
        <div class="cd-header">
          <input type="text" class="cd-search" placeholder="${searchPlaceholder}" />
          <div class="cd-actions"><button type="button" data-cd="clear">Clear</button></div>
        </div>
        <div class="cd-selectall"><label><input type="checkbox" data-cd="selectall"/> Select all</label></div>
        <div class="cd-list"></div>
        <div class="cd-footer"><span data-cd="summary">0 selected</span><span>Click outside to close</span></div>`;
      root.appendChild(panel);

      const list=panel.querySelector('.cd-list');
      const search=panel.querySelector('.cd-search');
      const clearBtn=panel.querySelector('[data-cd="clear"]');
      const selectAll=panel.querySelector('[data-cd="selectall"]');
      const summary=panel.querySelector('[data-cd="summary"]');

      let options=[]; let selected=new Set();

      function render(filter=''){
        const ft=filter.trim().toLowerCase(); list.innerHTML='';
        const filtered=!ft?options:options.filter(o=>(o.label||'').toLowerCase().includes(ft));
        if(!filtered.length){ list.innerHTML=`<div class="cd-item" style="color:#6C757D">No matches</div>`; return; }
        filtered.forEach(o=>{
          const id=`${containerId}__${o.value}`;
          const row=document.createElement('div'); row.className='cd-item';
          row.innerHTML=`<label for="${id}"><input type="checkbox" id="${id}" value="${o.value}" ${selected.has(o.value)?'checked':''}/><span>${o.label||o.value}</span></label>`;
          row.querySelector('input').addEventListener('change',(e)=>{
            if(e.target.checked) selected.add(o.value);
            else selected.delete(o.value);
            updateSummary();
            updateSelectAllState();
            if(containerId !== 'analyticsTeamDropdown') updateLoadButtonState();
          });
          list.appendChild(row);
        });
      }
      function updateSummary(){ trigger.querySelector('.count').textContent=`${selected.size} selected`; summary.textContent=`${selected.size} selected`; }
      function updateSelectAllState(){ const total=options.length,count=selected.size; selectAll.indeterminate=count>0&&count<total; selectAll.checked=total>0&&count===total; }

      trigger.addEventListener('click',()=>{ panel.classList.toggle('open'); search.focus(); });
      document.addEventListener('click',(e)=>{ if(!root.contains(e.target)) panel.classList.remove('open'); });
      search.addEventListener('input',()=>render(search.value));
      clearBtn.addEventListener('click',()=>{ selected.clear(); render(search.value); updateSummary(); updateSelectAllState(); if(containerId !== 'analyticsTeamDropdown') updateLoadButtonState(); });
      selectAll.addEventListener('change',()=>{ if(selectAll.checked) options.forEach(o=>selected.add(o.value)); else selected.clear(); render(search.value); updateSummary(); if(containerId !== 'analyticsTeamDropdown') updateLoadButtonState(); });

      function setOptions(newOptions){ options=newOptions||[]; selected.forEach(v=>{ if(!options.some(o=>o.value===v)) selected.delete(v); }); render(search.value); updateSummary(); updateSelectAllState(); if(containerId !== 'analyticsTeamDropdown') updateLoadButtonState(); }
      function getSelectedValues(){ return Array.from(selected); }

      render(''); return { setOptions, getSelectedValues };
    }

    function updateLoadButtonState(){
      const hasMonth=document.getElementById('monthInput').value;
      const hasUsers=dropdowns.users && dropdowns.users.getSelectedValues().length>0;
      const hasTeams=dropdowns.teams && dropdowns.teams.getSelectedValues().length>0;
      const hasForms=dropdowns.forms && dropdowns.forms.getSelectedValues().length>0;
      document.getElementById('loadBtn').disabled=!(hasMonth && (hasUsers || hasTeams || hasForms));
    }

    // ===== Boot (handles errors + expiry, avoids redirect loops) =====
    document.addEventListener('DOMContentLoaded', function () {
      resolveColors();

      const rawHash = (window.location.hash || '').replace(/^#/, '');
      const params = new URLSearchParams(rawHash);

      // 1) OAuth error (prevents infinite redirect)
      const oauthError = params.get('error');
      if (oauthError) {
        const desc = decodeURIComponent(params.get('error_description') || '');
        history.replaceState(null, document.title, window.location.pathname + window.location.search);
        sessionStorage.removeItem('purecloud_token');
        sessionStorage.removeItem('purecloud_token_exp');

        document.getElementById('auth-message').textContent = 'Sign-in failed. Please refresh the page to try again.';
        document.getElementById('auth-message').className = 'error-message';
        return;
      }

      // 2) Token in hash
      const tokenFromHash = params.get('access_token');
      if (tokenFromHash) {
        const expiresIn = parseInt(params.get('expires_in') || '0', 10);
        const expAt = expiresIn ? Date.now() + (expiresIn - 60) * 1000 : 0; // pad by 60s
        sessionStorage.setItem('purecloud_token', tokenFromHash);
        if (expAt) sessionStorage.setItem('purecloud_token_exp', String(expAt));
        history.replaceState(null, document.title, window.location.pathname + window.location.search);
        startApp(tokenFromHash);
        return;
      }

      // 3) Token from session (if not expired)
      const tokenFromSession = sessionStorage.getItem('purecloud_token');
      const exp = parseInt(sessionStorage.getItem('purecloud_token_exp') || '0', 10);
      if (tokenFromSession && (!exp || Date.now() < exp)) {
        startApp(tokenFromSession);
        return;
      }

      // 4) No token yet - redirect to OAuth
      document.getElementById('auth-message').textContent = 'Redirecting to Genesys Cloud for authentication...';
      setTimeout(function(){ window.location.href = oauthUrl; }, 200);
    });

    function startApp(token){
      state.accessToken=token;
      document.getElementById('auth-message').textContent='Authenticated successfully!';
      document.getElementById('auth-message').className='success-message';
      setTimeout(()=>{ document.getElementById('authCard').style.display='none'; }, 800);
      document.getElementById('appContent').style.display='block';

      dropdowns.users=createCheckboxDropdown('userDropdown',{placeholder:'Select agents (optional)',searchPlaceholder:'Search agents...'});
      dropdowns.teams=createCheckboxDropdown('teamDropdown',{placeholder:'Select work teams (optional)',searchPlaceholder:'Search teams...'});
      dropdowns.forms=createCheckboxDropdown('formDropdown',{placeholder:'Select forms (optional)',searchPlaceholder:'Search forms...'});
      dropdowns.analyticsTeams=createCheckboxDropdown('analyticsTeamDropdown',{placeholder:'Filter teams (optional)',searchPlaceholder:'Search teams...'});

      document.getElementById('overviewTabButton').onclick=()=>setTab('overview');
      document.getElementById('analyticsTabButton').onclick=()=>setTab('analytics');
      document.getElementById('detailsTabButton').onclick=()=>setTab('details');
      document.getElementById('criticalTabButton').onclick=()=>setTab('critical');
      document.getElementById('loadBtn').onclick=loadEvaluations;

      document.getElementById('loadAnalyticsBtn').onclick=loadAnalyticsRange;
      document.getElementById('insightsSort').onchange=renderAgentInsights;
      document.getElementById('applyAnalyticsFilters').onclick=renderAnalytics;

      const m=new Date();
      const cur=`${m.getFullYear()}-${String(m.getMonth()+1).padStart(2,'0')}`;
      document.getElementById('monthInput').value = cur;
      document.getElementById('anaFrom').value = cur;
      document.getElementById('anaTo').value = cur;

      updateMonthRange();
      document.getElementById('monthInput').addEventListener('change',()=>{ updateMonthRange(); updateLoadButtonState(); });

      Promise.all([fetchAllUsers(), fetchAllTeams(), fetchAllForms()])
        .then(()=> {
          updateLoadButtonState();
          dropdowns.analyticsTeams.setOptions(state.teams.map(t=>({value:t.id,label:t.name})));
        })
        .catch(err => msg('Initial load failed: '+err.message,'error'));
    }

    function setTab(name){
      ['overview','analytics','details','critical'].forEach(n=>{
        document.getElementById(`${n}Tab`).classList.toggle('active', n===name);
        document.getElementById(`${n}TabButton`).classList.toggle('active', n===name);
      });
      if(name==='analytics') renderAnalytics();
    }

    function updateMonthRange(){
      const val=document.getElementById('monthInput').value;
      if(!val) return;
      const [y,m]=val.split('-').map(Number);
      state.monthStart=new Date(Date.UTC(y, m-1, 1, 0,0,0));
      state.monthEnd  =new Date(Date.UTC(y, m,   0, 23,59,59));
    }

    // ===== HTTP helper with spacing + retry/backoff =====
    async function rawFetch(url,options={}){
      const now=Date.now(); const delta=now-lastApiCall;
      if(delta<API_DELAY) await sleep(API_DELAY-delta);
      lastApiCall=Date.now();
      return fetch(url,{...options,headers:{'Authorization':'Bearer '+state.accessToken,'Content-Type':'application/json',...(options.headers||{})}});
    }

    async function fetchJsonWithRetry(url, options={}, {retries=5, baseDelay=500}={}){
      let attempt=0;
      while(true){
        const res = await rawFetch(url, options);
        if(res.ok){
          if(res.status===204) return null;
          return await res.json();
        }
        if([400,401,403,404,405].includes(res.status)){
          if(res.status === 401 || res.status === 403) {
            // Token expired or invalid
            sessionStorage.removeItem('purecloud_token');
            sessionStorage.removeItem('purecloud_token_exp');
            document.getElementById('appContent').style.display='none';
            document.getElementById('authCard').style.display='block';
            document.getElementById('auth-message').textContent='Session expired. Redirecting to login...';
            document.getElementById('auth-message').className='info-message';
            setTimeout(() => { window.location.href = oauthUrl; }, 2000);
            throw new Error('Authentication required');
          }
          const err=new Error(`HTTP ${res.status}`); err.status=res.status; throw err;
        }
        attempt++;
        if(attempt>retries){
          const err=new Error(`HTTP ${res.status}`); err.status=res.status; throw err;
        }
        const retryAfter = Number(res.headers.get('Retry-After')) || null;
        const delay = retryAfter ? retryAfter*1000 : Math.round(baseDelay * (2**(attempt-1)) * (1 + Math.random()*0.25));
        await sleep(delay);
      }
    }

    async function fetchPaginatedGET(url){
      let all=[]; let next=url;
      while(next){
        const data = await fetchJsonWithRetry(next, {method:'GET'});
        if(Array.isArray(data.entities)) all=all.concat(data.entities);
        else if(Array.isArray(data.users)) all=all.concat(data.users);
        else if(Array.isArray(data)) all=all.concat(data);
        else if(data.entities) all=all.concat(data.entities);
        next = data.nextUri ? `https://api.${config.REGION}${data.nextUri}` : null;
      }
      return all;
    }

    function safeGet(o,p,def=null){ try{ return p.split('.').reduce((x,k)=>(x && k in x)?x[k]:undefined ,o) ?? def; }catch{ return def; } }
    function pct(n,d=1){ if(n==null||!isFinite(n)) return '-'; return (Math.round(n*10**d)/10**d).toFixed(d)+'%'; }
    function fmt(n,d=1){ if(n==null||!isFinite(n)) return '-'; return (Math.round(n*10**d)/10**d).toFixed(d); }
    function toUKDate(d){ const dt=new Date(d); return dt.toLocaleDateString('en-GB'); }
    function dayKeyUTC(d){ const dt=new Date(d); return new Date(Date.UTC(dt.getUTCFullYear(),dt.getUTCMonth(),dt.getUTCDate())).toISOString().split('T')[0]; }

    // Analytics helper functions
    function getPassSettings(){
      const pass=parseFloat(document.getElementById('passTarget').value||'85');
      const band=parseFloat(document.getElementById('amberBand').value||'5');
      return {pass, band};
    }

    function colourFor(score, pass, band){
      if(score==null||!isFinite(score)) return COLORS.BAD;
      if(score>=pass) return COLORS.OK;
      if(score>=pass-band) return COLORS.WARN;
      return COLORS.BAD;
    }

    function standardiseMedia(m){
      const x=String(m||'').toUpperCase();
      if(x.includes('EMAIL')) return 'Email';
      if(x.includes('CALL')||x.includes('VOICE')||x==='CALL') return 'Voice';
      if(x.includes('CHAT')||x.includes('MESSAGE')) return 'Message';
      if(x.includes('SOCIAL')) return 'Social';
      return 'Other';
    }

    // Improved critical/fatal detection
    function getMaxScoreForQuestion(questionObj) {
      const opts = [...(questionObj?.answerOptions || []), ...(questionObj?.options || [])];
      if (opts.length > 0) { return Math.max(...opts.map(opt => Number(opt.value) || 0)); }
      return Number(questionObj?.maxScore) || 1;
    }

    function detectCriticalFatalQuestions(qScore, questionObj) {
      const isFatal = !!(qScore.failedKillQuestion || qScore.isKill || qScore.isFatal);
      const explicitCritFail = !!(qScore.failedCriticalQuestion);
      if (qScore.notApplicable) {
        return { isFatal, isCritical: explicitCritFail };
      }
      const criticalFlag = !!( qScore.isCritical || safeGet(qScore,'question.isCritical') || safeGet(questionObj,'criticalQuestion') || safeGet(questionObj,'isCritical') );
      const maxScore = getMaxScoreForQuestion(questionObj || {});
      let currentScore = Number(qScore.score);
      if (!isFinite(currentScore)) currentScore = 0;
      const markdownByScore = criticalFlag && maxScore > 0 && currentScore < maxScore;
      return { isFatal, isCritical: explicitCritFail || markdownByScore };
    }

    // Stacked bar chart init - now uses actual data
    function initializeStackedBarChart(dailyData) {
      const ctx = document.getElementById('dailyTrendChart').getContext('2d');
      const labels = dailyData.map(d => d.date);
      const passedData = dailyData.map(d => d.passed);
      const amberData = dailyData.map(d => d.amber);
      const failedData = dailyData.map(d => d.failed);
      return new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [
          { label: 'Passed', data: passedData, backgroundColor: COLORS.OK,   borderColor: COLORS.OK,   borderWidth: 1 },
          { label: 'Amber',  data: amberData, backgroundColor: COLORS.WARN, borderColor: COLORS.WARN, borderWidth: 1 },
          { label: 'Failed', data: failedData, backgroundColor: COLORS.BAD,  borderColor: COLORS.BAD,  borderWidth: 1 }
        ]},
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: {
            x: { stacked: true, grid: { color: 'rgba(0,0,0,0.1)' } },
            y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Number of Evaluations' }, grid: { color: 'rgba(0,0,0,0.1)' } }
          },
          plugins: {
            legend: { position: 'top', labels: { color: COLORS.TEXT } },
            title: { display: true, text: 'Daily Performance Trend', color: COLORS.TEXT }
          }
        }
      });
    }

    let dailyTrendChart = null;

    // Table sorter
    function tableSorter(tableId){
      const t=document.getElementById(tableId);
      if(!t||!t.tHead) return;
      const ths=[...t.tHead.querySelectorAll('th')];
      ths.forEach((th,i)=>{
        th.onclick=()=>{
          const dir=th.dataset.dir==='asc'?'desc':'asc';
          ths.forEach(h=>{
            h.dataset.dir='';
            const s=h.querySelector('.sort-ind');
            if(s) s.remove();
          });
          th.dataset.dir=dir;
          const ind=document.createElement('span');
          ind.className='sort-ind';
          ind.textContent=dir==='asc'?'▲':'▼';
          th.appendChild(ind);
          const body=t.tBodies[0];
          const rows=[...body.rows];
          const num=th.dataset.type==='num';
          rows.sort((a,b)=>{
            const av=a.cells[i].getAttribute('data-sort') ?? a.cells[i].innerText;
            const bv=b.cells[i].getAttribute('data-sort') ?? b.cells[i].innerText;
            const A=num?Number(av):String(av).toLowerCase();
            const B=num?Number(bv):String(bv).toLowerCase();
            return dir==='asc'? (A>B?1:A<B?-1:0) : (A<B?1:A>B?-1:0);
          });
          body.innerHTML='';
          rows.forEach(r=>body.appendChild(r));
        };
      });
      t.classList.add('sortable');
    }

    // ===== Lookups =====
    async function fetchAllUsers(){
      const url=`https://api.${config.REGION}/api/v2/users?pageSize=100`;
      const users=await fetchPaginatedGET(url);
      state.users=users.map(u=>({id:u.id,name:(u.name || `${u.givenName||''} ${u.familyName||''}`).trim(),email:u.email||''})).sort((a,b)=>a.name.localeCompare(b.name));
      dropdowns.users.setOptions(state.users.map(u=>({value:u.id,label:`${u.name}${u.email?` — ${u.email}`:''}`})));
    }

    async function fetchAllTeams(){
      const url=`https://api.${config.REGION}/api/v2/teams?pageSize=100`;
      const teams = await fetchPaginatedGET(url);
      state.teams = teams.map(t=>({id:t.id,name:t.name||'(Unnamed team)'})).sort((a,b)=>a.name.localeCompare(b.name));
      state.teamsById = Object.fromEntries(state.teams.map(t=>[t.id,t]));
      dropdowns.teams.setOptions(state.teams.map(t=>({value:t.id,label:t.name})));
    }

    async function ensureTeamMembersLoaded(teamIds){
      const missing = teamIds.filter(id=>!state.teamMembers.has(id));
      if(!missing.length) return;
      await Promise.all(missing.map(fetchTeamMembers));
    }

    async function fetchTeamMembers(teamId){
      const url=`https://api.${config.REGION}/api/v2/teams/${teamId}/members?pageSize=100`;
      const members=await fetchPaginatedGET(url);
      const ids = Array.from(new Set(members.map(m => safeGet(m,'member.id') || safeGet(m,'member.user.id') || safeGet(m,'user.id') || safeGet(m,'id')).filter(Boolean)));
      state.teamMembers.set(teamId, ids);
    }

    async function fetchAllForms(){
      const url=`https://api.${config.REGION}/api/v2/quality/forms/evaluations?pageSize=100`;
      const forms=await fetchPaginatedGET(url);
      state.forms=forms.map(f=>({id:f.id,name:f.name||f.title||'(Unnamed form)'})).sort((a,b)=>a.name.localeCompare(b.name));
      state.formsById=Object.fromEntries(state.forms.map(f=>[f.id,f]));
      dropdowns.forms.setOptions(state.forms.map(f=>({value:f.id,label:f.name})));
    }

    async function computeSelectedAgentIds(){
      const userIds = dropdowns.users.getSelectedValues();
      const teamIds = dropdowns.teams.getSelectedValues();
      const set = new Set(userIds);
      if(teamIds.length){
        await ensureTeamMembersLoaded(teamIds);
        teamIds.forEach(tid=>{
          (state.teamMembers.get(tid)||[]).forEach(uid=>set.add(uid));
        });
      }
      return Array.from(set);
    }

    // Helper for analytics team filtering
    async function agentsForTeams(teamIds){
      await ensureTeamMembersLoaded(teamIds);
      const ids=new Set();
      teamIds.forEach(tid=>(state.teamMembers.get(tid)||[]).forEach(id=>ids.add(id)));
      return Array.from(ids);
    }

    // ===== Evaluations with GET/POST fallback + retry =====
    async function loadEvaluations(){
      const agentIds = await computeSelectedAgentIds();
      const formIds = dropdowns.forms.getSelectedValues();

      if(agentIds.length===0 && formIds.length===0){
        msg('Please select at least one agent, team, or form.','error');
        return;
      }
      if(!state.monthStart || !state.monthEnd){
        msg('Please select a month.','error');
        return;
      }

      const btn=document.getElementById('loadBtn'); setLoading(btn,true); msg('Loading evaluations…','info');
      try{
        const agentList = agentIds.length ? agentIds : state.users.map(u=>u.id);
        state.evals = await fetchDetailedEvaluations(agentList, formIds, state.monthStart, state.monthEnd);
        
        // CRITICAL FIX: Load ALL form details for ALL forms found in evaluations
        await loadAllFormDetailsFromEvaluations(state.evals);
        
        msg(`Loaded ${state.evals.length} evaluations.`,'success');
        renderAll();
      }catch(e){ console.error(e); msg('Failed to load evaluations: '+e.message,'error'); }
      finally{ setLoading(btn,false); }
    }

    async function loadAnalyticsRange(){
      const from=document.getElementById('anaFrom').value;
      const to=document.getElementById('anaTo').value;
      if(!from || !to){ msg('Select both From and To months for Analytics.','error'); return; }
      const [fy,fm]=from.split('-').map(Number);
      const [ty,tm]=to.split('-').map(Number);
      const start=new Date(Date.UTC(fy, fm-1, 1, 0,0,0));
      const end  =new Date(Date.UTC(ty, tm,   0, 23,59,59));
      if(start>end){ msg('The From month must be before the To month.','error'); return; }

      const formIds = dropdowns.forms.getSelectedValues();
      const agentIds = await computeSelectedAgentIds();
      if(agentIds.length===0 && formIds.length===0){
        msg('Please select at least one agent, team, or form.','error'); return;
      }

      const btn=document.getElementById('loadAnalyticsBtn'); setLoading(btn,true);
      try{
        const agentList = agentIds.length ? agentIds : state.users.map(u=>u.id);
        const data=await fetchDetailedEvaluations(agentList,formIds,start,end);
        state.analyticsEvals=data; state.analyticsRange={start,end};
        
        // CRITICAL FIX: Load ALL form details for ALL forms found in analytics evaluations
        await loadAllFormDetailsFromEvaluations(data);
        
        msg(`Analytics range loaded: ${data.length} evaluations.`, 'success');
        renderAnalytics();
      }catch(e){ console.error(e); msg('Failed to load analytics range: '+e.message,'error'); }
      finally{ setLoading(btn,false); }
    }

    // NEW FUNCTION: Load ALL form details from evaluations
    async function loadAllFormDetailsFromEvaluations(evaluations) {
      if (!evaluations || evaluations.length === 0) return;
      
      console.log('Loading form details for all evaluations...');
      
      // Collect ALL unique form IDs from evaluations
      const formPromises = new Set();
      
      evaluations.forEach(e => {
        const pubId = safeGet(e, 'evaluationForm.id');
        const formId = safeGet(e, 'form.id') || e.formId;
        const formVersionId = safeGet(e, 'form.versionId') || e.formVersionId || safeGet(e, 'form.version');
        
        // Add published form if exists
        if (pubId) {
          formPromises.add(getFormDetails(pubId, '__published__'));
        }
        
        // Add form with version if exists
        if (formId && formVersionId) {
          formPromises.add(getFormDetails(formId, formVersionId));
        }
        
        // Also add form without version as fallback
        if (formId) {
          formPromises.add(getFormDetails(formId, null));
        }
      });
      
      console.log(`Loading ${formPromises.size} form details...`);
      
      // Load all form details in parallel with limited concurrency
      const promisesArray = Array.from(formPromises);
      const BATCH_SIZE = 5;
      
      for (let i = 0; i < promisesArray.length; i += BATCH_SIZE) {
        const batch = promisesArray.slice(i, i + BATCH_SIZE);
        await Promise.all(batch);
        if (i + BATCH_SIZE < promisesArray.length) {
          await sleep(500); // Brief pause between batches
        }
      }
      
      console.log('All form details loaded.');
    }

    async function fetchDetailedEvaluations(agentIds,formIds,startDate,endDate){
      const all=[];
      for(let i=0;i<agentIds.length;i+=MAX_CONCURRENT_AGENT_BATCH){
        const batch=agentIds.slice(i,i+MAX_CONCURRENT_AGENT_BATCH);
        const res=await Promise.all(batch.map(id=>fetchEvaluationsForAgentInterval(id,formIds,startDate,endDate)));
        res.forEach(items=>all.push(...items));
        if(i+MAX_CONCURRENT_AGENT_BATCH<agentIds.length) await sleep(300);
      }
      return all;
    }

    async function fetchEvaluationsForAgentInterval(agentId,formIds,startDate,endDate){
      const start=startDate.toISOString(); const end=endDate.toISOString();
      const base = `https://api.${config.REGION}/api/v2/quality/evaluations/query`;

      // Helper: GET path
      async function getViaGET(singleFormId){
        const params = new URLSearchParams({
          agentUserId: agentId,
          startTime: start,
          endTime: end,
          expandAnswerTotalScores: 'true',
          pageSize: '50'
        });
        if(singleFormId) params.set('formId', singleFormId);
        const url = `${base}?${params.toString()}`;
        let all=[]; let next=url;
        while(next){
          try{
            const data = await fetchJsonWithRetry(next,{method:'GET'});
            const entities = data?.entities || [];
            all = all.concat(entities);
            next = data?.nextUri ? `https://api.${config.REGION}${data.nextUri}` : null;
          }catch(err){ throw err; }
        }
        return all;
      }

      // Helper: POST path
      async function getViaPOST(){
        const url = base;
        const body = {
          agentUserIds: [agentId],
          interval: `${start}/${end}`,
          expandAnswerTotalScores: true,
          pageSize: 50
        };
        if(formIds && formIds.length>0) body.formIds = formIds;

        let page=1, all=[];
        while(true){
          body.pageNumber = page;
          try{
            const data = await fetchJsonWithRetry(url,{method:'POST',body:JSON.stringify(body)});
            const entities = data?.entities || [];
            if(!entities.length) break;
            all = all.concat(entities);
            if(!data.nextUri && entities.length < body.pageSize) break;
            page++;
          }catch(err){ throw err; }
        }
        return all;
      }

      if(!formIds || formIds.length<=1){
        try{ return await getViaGET(formIds?.[0]); }
        catch(err){ if(err.status===405 || err.status===400){ /* fallback */ } else throw err; }
      }

      try{ return await getViaPOST(); }
      catch(err){
        if(err.status===405 || err.status===400){ return await getViaGET(undefined); }
        throw err;
      }
    }

    // ===== Forms & lookups =====
    function formKey(formId, versionId){ 
      return (versionId === '__published__') ? `pub@${formId}` : `${formId}@${versionId || 'latest'}`; 
    }
    
    async function getFormDetails(formId, versionId){
      const key = formKey(formId, versionId);
      
      // Return cached if available
      if (state.formDetailsCache.has(key)) {
        console.log(`Form ${key} already cached`);
        return state.formDetailsCache.get(key);
      }
      
      console.log(`Loading form details for ${key}`);
      
      let url;
      if (versionId === '__published__') {
        url = `https://api.${config.REGION}/api/v2/quality/publishedforms/evaluations/${formId}`;
      } else {
        url = versionId
          ? `https://api.${config.REGION}/api/v2/quality/forms/evaluations/${formId}/versions/${versionId}`
          : `https://api.${config.REGION}/api/v2/quality/forms/evaluations/${formId}`;
      }
      
      try {
        let data;
        try {
          data = await fetchJsonWithRetry(url, { method: 'GET' });
        } catch (err) {
          // If specific version fails, try to get the latest version
          if (versionId && versionId !== '__published__') {
            console.log(`Version ${versionId} not found for form ${formId}, trying latest version`);
            data = await fetchJsonWithRetry(
              `https://api.${config.REGION}/api/v2/quality/forms/evaluations/${formId}`, 
              { method: 'GET' }
            );
          } else {
            throw err;
          }
        }
        
        // Store in cache
        state.formDetailsCache.set(key, data);
        state.formLookupCache.set(key, buildFormLookup(data || {}));
        
        console.log(`Form ${key} loaded successfully: ${data?.name || 'Unnamed form'}`);
        return data;
      } catch (e) {
        console.error(`Failed to load form ${key}:`, e.message);
        state.formDetailsCache.set(key, null);
        return null;
      }
    }

    // IMPROVED form lookup
    function buildFormLookup(form){
      console.log(`Building lookup for form: ${form?.name || 'Unknown'}`);
      
      const questionText = new Map();
      const answerText = new Map();
      const questionObj = new Map();
      
      if (!form) {
        console.log('No form data provided');
        return { questionText, answerText, questionObj };
      }

      function extractQuestionText(q) {
        return q.text || q.label || q.title || q.questionText || '';
      }

      function extractAnswerText(a) {
        return a.text || a.label || a.title || String(a.value || '');
      }

      function addQuestion(q, path = '') {
        if (!q) return;
        
        const qText = extractQuestionText(q);
        const qPath = path ? `${path}.${q.id || 'q'}` : (q.id || 'root');
        
        console.log(`Processing question: ${qText} (ID: ${q.id}, Path: ${qPath})`);
        
        // Collect all possible IDs
        const allIds = [];
        if (q.id) allIds.push(q.id);
        if (q.contextId) allIds.push(q.contextId);
        if (q.questionId) allIds.push(q.questionId);
        if (q.questionContextId) allIds.push(q.questionContextId);
        
        // For questions without proper IDs, generate one from the path
        if (allIds.length === 0 && qPath) {
          allIds.push(qPath);
        }
        
        // Map all IDs to question text
        allIds.forEach(id => {
          if (id && qText) {
            questionText.set(id, qText);
            questionObj.set(id, q);
            console.log(`  Mapped ID ${id} -> "${qText}"`);
          }
        });
        
        // Handle answer options
        (q.answerOptions || []).forEach((a, idx) => {
          const aText = extractAnswerText(a);
          const answerIds = [];
          
          if (a.id) answerIds.push(a.id);
          if (a.contextId) answerIds.push(a.contextId);
          if (a.answerId) answerIds.push(a.answerId);
          if (a.answerOptionId) answerIds.push(a.answerOptionId);
          
          // Generate ID if none exists
          if (answerIds.length === 0) {
            answerIds.push(`${qPath}.answer.${idx}`);
          }
          
          answerIds.forEach(id => {
            if (id && aText) {
              answerText.set(id, aText);
              console.log(`  Mapped answer ID ${id} -> "${aText}"`);
            }
          });
        });
        
        // Handle nested questions
        (q.multipleSelectOptionQuestions || []).forEach(nested => 
          addQuestion(nested, `${qPath}.nested`));
        (q.nestedQuestions || []).forEach(nested => 
          addQuestion(nested, `${qPath}.nested`));
      }

      function walkQuestionGroups(groups, path = '') {
        (groups || []).forEach((g, gIdx) => {
          const groupPath = path ? `${path}.group${gIdx}` : `group${gIdx}`;
          
          // Process questions in group
          (g.questions || []).forEach((q, qIdx) => 
            addQuestion(q, `${groupPath}.q${qIdx}`));
          
          // Recursively walk nested groups
          walkQuestionGroups(g.questionGroups || [], groupPath);
        });
      }
      
      // Process top-level questions
      (form.questions || []).forEach((q, idx) => 
        addQuestion(q, `q${idx}`));
      
      // Process question groups
      walkQuestionGroups(form.questionGroups || []);
      
      console.log(`Lookup built: ${questionText.size} questions, ${answerText.size} answers`);
      return { questionText, answerText, questionObj };
    }

    async function getCombinedLookupForEval(e){
      const pubId = safeGet(e, 'evaluationForm.id');
      const formId = safeGet(e, 'form.id') || e.formId;
      const formVersionId = safeGet(e, 'form.versionId') || e.formVersionId || safeGet(e, 'form.version');
      
      // Create a more robust cache key
      const comboKey = [
        pubId ? `pub:${pubId}` : '',
        formId ? `form:${formId}` : '',
        formVersionId ? `ver:${formVersionId}` : '',
        e.id ? `eval:${e.id}` : ''
      ].filter(Boolean).join('|') || 'none';
      
      if (state.combinedLookupCache.has(comboKey)) {
        return state.combinedLookupCache.get(comboKey);
      }
      
      console.log(`Creating combined lookup for evaluation: ${comboKey}`);
      
      // Load ALL possible form details
      const detailsPromises = [];
      
      if (pubId) {
        detailsPromises.push(getFormDetails(pubId, '__published__'));
      }
      
      if (formId && formVersionId) {
        detailsPromises.push(getFormDetails(formId, formVersionId));
      }
      
      if (formId && !formVersionId) {
        detailsPromises.push(getFormDetails(formId, null));
      }
      
      // Always try to get the form regardless of version
      if (formId) {
        detailsPromises.push(getFormDetails(formId, null));
      }
      
      const details = (await Promise.all(detailsPromises)).filter(Boolean);
      
      if (details.length === 0) {
        console.warn(`No form details found for evaluation ${e.id}`);
      }
      
      const merged = { 
        questionText: new Map(), 
        answerText: new Map(), 
        questionObj: new Map() 
      };
      
      const names = [];
      
      details.forEach(d => {
        if (d?.name) names.push(d.name);
        const lk = buildFormLookup(d || {});
        
        // Merge all lookups
        lk.questionText.forEach((v, k) => merged.questionText.set(k, v));
        lk.answerText.forEach((v, k) => merged.answerText.set(k, v));
        lk.questionObj.forEach((v, k) => merged.questionObj.set(k, v));
      });
      
      const formName = safeGet(e, 'evaluationForm.name') || 
                      safeGet(e, 'form.name') || 
                      names[0] || 
                      '(Unknown Form)';
      
      const combined = {
        ...merged,
        formName,
        formId: formId,
        formVersionId: formVersionId,
        pubId: pubId
      };
      
      state.combinedLookupCache.set(comboKey, combined);
      
      console.log(`Combined lookup created: ${merged.questionText.size} questions for form "${formName}"`);
      return combined;
    }

    // ===== Question Text Resolution =====
    function approx(a,b){ return Math.abs(Number(a)-Number(b))<1e-6; }
    
    function resolveQuestionTextWithLookup(lookup, qScore) {
      // First, try direct lookup with all possible IDs
      const possibleIds = [
        qScore.questionId,
        qScore.questionContextId,
        safeGet(qScore, 'question.id'),
        safeGet(qScore, 'question.contextId'),
        safeGet(qScore, 'question.questionId'),
        safeGet(qScore, 'question.questionContextId'),
        safeGet(qScore, 'id')
      ].filter(Boolean);
      
      for (const id of possibleIds) {
        const text = lookup.questionText.get(id);
        if (text) {
          return text;
        }
      }
      
      // If no ID match, try to find by scanning all questions for matching text
      if (qScore.questionId || qScore.questionContextId) {
        // Try to find question with similar ID pattern
        const allQuestionIds = Array.from(lookup.questionText.keys());
        const targetId = qScore.questionId || qScore.questionContextId;
        
        // Look for partial matches
        for (const questionId of allQuestionIds) {
          if (questionId.includes(targetId) || targetId.includes(questionId)) {
            const text = lookup.questionText.get(questionId);
            if (text) return text;
          }
        }
      }
      
      // Try to get from qScore directly
      const directText = safeGet(qScore, 'question.text') || 
                        safeGet(qScore, 'question.label') || 
                        safeGet(qScore, 'question.title') ||
                        safeGet(qScore, 'text');
      
      if (directText) {
        return directText;
      }
      
      // Try to extract from the question object if available
      const questionObj = safeGet(qScore, 'question');
      if (questionObj) {
        const objText = questionObj.text || questionObj.label || questionObj.title;
        if (objText) return objText;
      }
      
      // Last resort - show something informative
      const firstId = possibleIds[0];
      if (firstId) {
        // Check if this might be a contextId vs questionId issue
        console.warn(`Question text not found for ID: ${firstId}`);
        console.warn(`Available question IDs in lookup:`, Array.from(lookup.questionText.keys()));
        return `Question (${firstId.substring(0, Math.min(12, firstId.length))}${firstId.length > 12 ? '...' : ''})`;
      }
      
      return 'Unknown Question';
    }

    function resolveAnswerTextWithLookup(lookup, qScore) {
      // Try to get answer text from lookup
      const ids = new Set();
      
      // Collect ALL possible answer IDs
      (qScore.selectedAnswerIds || []).forEach(x => ids.add(x));
      (qScore.selectedAnswerOptionIds || []).forEach(x => ids.add(x));
      if (qScore.selectedAnswerId) ids.add(qScore.selectedAnswerId);
      if (qScore.answerOptionId) ids.add(qScore.answerOptionId);
      if (qScore.answerId) ids.add(qScore.answerId);
      
      const a = qScore.answer || {};
      [a.id, a.contextId, a.answerId, a.answerOptionId].filter(Boolean).forEach(x => ids.add(x));
      
      (qScore.answers || []).forEach(ans => { 
        [ans.id, ans.contextId, ans.answerId, ans.answerOptionId].filter(Boolean).forEach(x => ids.add(x)); 
      });
      
      const texts = [];
      Array.from(ids).forEach(id => { 
        const t = lookup.answerText.get(id); 
        if (t) texts.push(t); 
      });
      
      if (texts.length) return texts.join(', ');
      
      // If no answer text found, try to match score to answer options
      const qIds = [ qScore.questionId, qScore.questionContextId, safeGet(qScore, 'question.id'), safeGet(qScore, 'question.contextId') ].filter(Boolean);
      const q = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
      
      if (q && Array.isArray(q.answerOptions) && q.answerOptions.length) {
        const s = Number(qScore.score);
        const match = q.answerOptions.find(o => 
          approx(s, o.value) || 
          approx(s / 100, o.value) || 
          approx(s, o.value * 100) || 
          (o.value === 0 && s === 0) 
        );
        if (match) { 
          return match.text || match.label || String(match.value || ''); 
        }
        if (qScore.score !== null && qScore.score !== undefined) { 
          return `Score: ${qScore.score}`; 
        }
      }
      
      // Fallbacks
      if (qScore.freeTextAnswer) return String(qScore.freeTextAnswer);
      if (qScore.numericAnswer !== undefined && qScore.numericAnswer !== null) return String(qScore.numericAnswer);
      if (safeGet(qScore, 'answer.text')) return qScore.answer.text;
      if (qScore.score !== null && qScore.score !== undefined) { return `Score: ${qScore.score}`; }
      
      return 'No answer';
    }

    // ===== Renderers =====
    function renderAll(){ renderOverview(); renderAnalytics(); renderDetails(); renderCritical(); }
    function resolveUserName(id){ const u=state.users.find(x=>x.id===id); return u?u.name:(id||'(unknown)'); }
    function getEvalPercent(e){
      const p=e.totalScore || e.totalPercent || safeGet(e,'scoring.totalPercent') || safeGet(e,'oTotalPercent') || safeGet(e,'answers.totalScore');
      if(p==null) return null; return p<=1 ? p*100 : p;
    }

    function renderOverview(){
      const evals=state.evals;
      const byAgent=new Map();
      evals.forEach(e=>{
        const a=safeGet(e,'agent.id') || e.agentUserId || e.userId || '(unknown)';
        const p=getEvalPercent(e);
        if(!byAgent.has(a)) byAgent.set(a,{count:0,sum:0});
        const o=byAgent.get(a); o.count++; if(p!=null && isFinite(p)) o.sum+=Number(p);
      });
      const rows=[]; let total=0;
      for(const [aid,{count,sum}] of byAgent.entries()){ rows.push({agent:resolveUserName(aid),count,avg:count?(sum/count):null}); total+=count; }
      rows.sort((a,b)=>a.agent.localeCompare(b.agent));
      const overallAvg=(rows.length && total)?(rows.reduce((s,r)=>s+(r.avg||0),0)/rows.length):null;

      document.getElementById('overviewKPIs').innerHTML=`
        <div class="kpi"><div class="label">Month</div><div class="value">${document.getElementById('monthInput').value}</div></div>
        <div class="kpi"><div class="label">Evaluations</div><div class="value">${evals.length}</div></div>
        <div class="kpi"><div class="label">Agents</div><div class="value">${rows.length}</div></div>
        <div class="kpi"><div class="label">Average Score (Agent Avg)</div><div class="value">${overallAvg==null?'-':pct(overallAvg,1)}</div></div>`;
      const tbl=document.getElementById('agentSummaryTable');
      tbl.innerHTML = rows.length
        ? `<thead><tr><th>Agent</th><th>Evaluations</th><th>Average Score</th></tr></thead>
           <tbody>${rows.map(r=>`<tr><td>${r.agent}</td><td>${r.count}</td><td>${r.avg==null?'-':pct(r.avg,1)}</td></tr>`).join('')}</tbody>`
        : '<tr><td colspan="3" class="muted">No evaluation data available for the selected criteria.</td></tr>';
    }

    function getAnalyticsSet(){ return (state.analyticsEvals && state.analyticsRange) ? state.analyticsEvals : state.evals; }
    function guessMediaType(e){ return standardiseMedia(safeGet(e,'mediaType') || safeGet(e,'conversation.mediaType') || 'Unknown'); }
    function buildDays(start,end){ const out=[]; for(let d=new Date(start); d<=end; d.setUTCDate(d.getUTCDate()+1)){ out.push(new Date(d)); } return out; }

    function calculateDailyTrendData(evals, start, end) {
      const {pass, band} = getPassSettings();
      const dailyMap = new Map();
      const days = buildDays(start, end);
      days.forEach(day => {
        const dayKey = dayKeyUTC(day);
        dailyMap.set(dayKey, { date: toUKDate(day), passed: 0, amber: 0, failed: 0 });
      });
      evals.forEach(e => {
        const dayKey = dayKeyUTC(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        if (dailyMap.has(dayKey)) {
          const score = getEvalPercent(e);
          const dayData = dailyMap.get(dayKey);
          if (score === null || !isFinite(score)) { dayData.failed++; }
          else if (score >= pass) { dayData.passed++; }
          else if (score >= pass - band) { dayData.amber++; }
          else { dayData.failed++; }
        }
      });
      return Array.from(dailyMap.values());
    }

    async function renderAnalytics(){
      const raw = getAnalyticsSet();
      if(!raw || !raw.length){
        document.getElementById('analyticsKPIs').innerHTML='';
        document.getElementById('mediaTable').innerHTML='<tr><td class="muted">No data loaded yet.</td></tr>';
        document.getElementById('repeatFailsTable').innerHTML='';
        document.getElementById('agentInsights').innerHTML='';
        document.getElementById('trendTable').innerHTML='';
        document.getElementById('topAgentsTable').innerHTML='';
        document.getElementById('bottomAgentsTable').innerHTML='';
        document.getElementById('agentMediaChart').innerHTML='';
        return;
      }

      const teamFilter = dropdowns.analyticsTeams.getSelectedValues();
      let allowedAgents = null;
      if(teamFilter.length){ allowedAgents = new Set(await agentsForTeams(teamFilter)); }
      const evals = allowedAgents ? raw.filter(e => allowedAgents.has(safeGet(e,'agent.id')||e.agentUserId)) : raw;

      const start = state.analyticsRange?.start || state.monthStart;
      const end   = state.analyticsRange?.end   || state.monthEnd;
      const dailyTrendData = calculateDailyTrendData(evals, start, end);
      if (dailyTrendChart) { dailyTrendChart.destroy(); }
      dailyTrendChart = initializeStackedBarChart(dailyTrendData);

      let withFatal=0, withCritical=0, totalCriticalMarks=0, totalFatalMarks=0;
      let sumScores=0, scored=0;
      for (const e of evals) {
        const qgs = safeGet(e, 'answers.questionGroupScores') || [];
        let evalHasFatal = false, evalHasCritical = false;
        for (const g of qgs) {
          for (const q of (g.questionScores || [])) {
            const lookup = await getCombinedLookupForEval(e);
            const qIds = [q.questionId, q.questionContextId, safeGet(q, 'question.id'), safeGet(q, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(q, questionObj);
            if (isFatal) { evalHasFatal = true; totalFatalMarks++; }
            if (isCritical) { evalHasCritical = true; totalCriticalMarks++; }
          }
        }
        if (evalHasFatal) withFatal++;
        if (evalHasCritical) withCritical++;
        const p=getEvalPercent(e); if(p!=null && isFinite(p)){ sumScores+=Number(p); scored++; }
      }
      const avgOverall = scored? (sumScores/scored): null;
      const passRate = evals.length? ((evals.length - Math.max(withFatal, withCritical))/evals.length): null;

      document.getElementById('analyticsKPIs').innerHTML = `
        <div class="kpi"><div class="label">Evaluations Completed</div><div class="value">${evals.length}</div></div>
        <div class="kpi"><div class="label">Avg Score</div><div class="value">${avgOverall==null?'-':pct(avgOverall,1)}</div></div>
        <div class="kpi"><div class="label">Critical Questions Scored</div><div class="value">${totalCriticalMarks}</div></div>
        <div class="kpi"><div class="label">Critical Markdowns</div><div class="value">${withCritical}</div></div>
        <div class="kpi"><div class="label">Fatal Evaluations</div><div class="value">${withFatal}</div></div>
        <div class="kpi"><div class="label">Fatal Marks</div><div class="value">${totalFatalMarks}</div></div>
        <div class="kpi"><div class="label">Pass Rate</div><div class="value">${passRate==null?'-':pct(passRate*80,1)}</div></div>
      `;

      const {pass, band} = getPassSettings();
      const byAgent=new Map(); // agent -> media -> {count,sum,scored}
      evals.forEach(e=>{
        const aid=safeGet(e,'agent.id')||e.agentUserId||'(unknown)';
        const name=resolveUserName(aid);
        const mt=guessMediaType(e);
        if(!byAgent.has(aid)) byAgent.set(aid,{name,map:new Map()});
        const m=byAgent.get(aid).map;
        if(!m.has(mt)) m.set(mt,{count:0,sum:0,scored:0});
        const o=m.get(mt);
        o.count++;
        const p=getEvalPercent(e);
        if(p!=null&&isFinite(p)){ o.sum+=Number(p); o.scored++; }
      });
      const mediaOrder = ['Voice','Email','Message','Social','Other'];
      const width=700, height=22;
      const rowsHtml = Array.from(byAgent.values()).sort((a,b)=>a.name.localeCompare(b.name)).map(row=>{
        const total=Array.from(row.map.values()).reduce((s,o)=>s+o.count,0)||1;
        let x=0;
        const rects = mediaOrder.map(type=>{
          const o=row.map.get(type);
          if(!o) return '';
          const w=Math.max(1, Math.round((o.count/total)*width));
          const avg = o.scored? (o.sum/o.scored) : null;
          const fill = colourFor(avg, pass, band);
          const tooltip = `${type}: ${o.count} evals · ${avg==null?'-':pct(avg,1)}`;
          const rx=x; x+=w;
          return `<rect x="${rx}" y="0" width="${w}" height="${height}" fill="${fill}"><title>${tooltip}</title></rect>`;
        }).join('');
        const label = Array.from(row.map.entries()).map(([t,o])=>`${t}:${o.count}`).join(' • ');
        return `<div class="chart-row">
                  <div class="chart-label" title="${row.name}">${row.name}</div>
                  <svg class="chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none" width="100%" height="${height+2}">
                    ${rects}
                  </svg>
                  <div class="muted" style="width:180px; text-align:right">${label}</div>
                </div>`;
      }).join('');
      document.getElementById('agentMediaChart').innerHTML = rowsHtml || '<div class="muted">No data</div>';

      const mediaMap=new Map();
      evals.forEach(e=>{
        const mt=guessMediaType(e);
        if(!mediaMap.has(mt)) mediaMap.set(mt,{count:0,sum:0,scored:0});
        const o=mediaMap.get(mt); o.count++;
        const p=getEvalPercent(e); if(p!=null && isFinite(p)){ o.sum+=Number(p); o.scored++; }
      });
      const mediaRows = Array.from(mediaMap.entries()).map(([mt,o])=>{
        const avg = o.scored? (o.sum/o.scored) : null;
        return `<tr>
          <td>${mt}</td>
          <td data-sort="${o.count}">${o.count}</td>
          <td data-sort="${avg==null?0:avg.toFixed(2)}">${avg==null?'-':pct(avg,1)}</td>
        </tr>`;
      }).join('');
      document.getElementById('mediaTable').innerHTML = `
        <thead><tr>
          <th data-type="text">Media Type</th>
          <th data-type="num">Evaluations</th>
          <th data-type="num">Avg Score</th>
        </tr></thead>
        <tbody>${mediaRows}</tbody>
      `;
      tableSorter('mediaTable');

      const failMap=new Map();
      for(const e of evals){
        const lookup = await getCombinedLookupForEval(e);
        const qgs=safeGet(e,'answers.questionGroupScores')||[];
        qgs.forEach(g=> (g.questionScores||[]).forEach(q=>{
          const qIds = [q.questionId, q.questionContextId, safeGet(q, 'question.id'), safeGet(q, 'question.contextId')].filter(Boolean);
          const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
          const { isFatal, isCritical } = detectCriticalFatalQuestions(q, questionObj);
          if (isFatal || isCritical) {
            const qText = resolveQuestionTextWithLookup(lookup,q);
            const key = `${lookup.formName}|${qText}`;
            if(!failMap.has(key)) failMap.set(key,{formName:lookup.formName,qText,critical:0,fatal:0});
            const o=failMap.get(key);
            if(isFatal) o.fatal++;
            else if(isCritical) o.critical++;
          }
        }));
      }
      
      const repeatRows = Array.from(failMap.values())
        .sort((a,b)=>(b.fatal+b.critical)-(a.fatal+a.critical))
        .map(r=>`<tr>
          <td>${r.formName}</td>
          <td>${r.qText}</td>
          <td data-sort="${r.critical}">${r.critical}</td>
          <td data-sort="${r.fatal}">${r.fatal}</td>
          <td data-sort="${r.critical+r.fatal}">${r.critical+r.fatal}</td></tr>`)
        .join('');
        
      document.getElementById('repeatFailsTable').innerHTML = `
        <thead><tr>
          <th data-type="text">Form</th><th data-type="text">Question</th>
          <th data-type="num">Critical</th><th data-type="num">Fatal</th><th data-type="num">Total</th>
        </tr></thead>
        <tbody>${repeatRows || `<tr><td colspan="5" class="muted">No critical/fatal marks found.</td></tr>`}</tbody>
      `;
      tableSorter('repeatFailsTable');

      const byAgentInsight=new Map();
      evals.forEach(e=>{
        const id=safeGet(e,'agent.id')||e.agentUserId||'(unknown)';
        const name=resolveUserName(id);
        if(!byAgentInsight.has(id)) byAgentInsight.set(id,{name,count:0,sum:0,scored:0,fails:0});
        const o=byAgentInsight.get(id);
        o.count++;
        const p=getEvalPercent(e); if(p!=null && isFinite(p)){ o.sum+=Number(p); o.scored++; }
        const hasFail=(safeGet(e,'answers.questionGroupScores')||[]).some(g=>(g.questionScores||[]).some(q=>{
          const isF = !!q.failedKillQuestion; const isC = !!q.failedCriticalQuestion;
          return isF || isC;
        }));
        if(hasFail) o.fails++;
      });
      const insightArr = Array.from(byAgentInsight.values()).map(o=>({ name:o.name, count:o.count, avg:o.scored?o.sum/o.scored:null, fails:o.fails }));
      window._insightData = insightArr;
      renderAgentInsights();

      const dayKeys = dailyTrendData.map(d => d.date);
      const agents = Array.from(new Set(evals.map(e=> safeGet(e,'agent.id') || e.agentUserId))).filter(Boolean);
      const map = new Map();
      evals.forEach(e=>{
        const aid = safeGet(e,'agent.id') || e.agentUserId || '(unknown)';
        const dk = toUKDate(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const p = getEvalPercent(e);
        if(!map.has(aid)) map.set(aid, new Map());
        const dm = map.get(aid);
        if(!dm.has(dk)) dm.set(dk,{sum:0,count:0});
        if (p!=null && isFinite(p)) { const o=dm.get(dk); o.sum+=Number(p); o.count++; }
      });

      const header = `<thead><tr><th>Agent</th>${dayKeys.map(k=>`<th>${k}</th>`).join('')}</tr></thead>`;
      const rows = agents.map(aid=>{
        const dm = map.get(aid) || new Map();
        const cells = dayKeys.map(k=>{
          const v=dm.get(k);
          if(!v||v.count===0) return '<td>-</td>';
          return `<td>${pct(v.sum/v.count,1)}</td>`;
        }).join('');
        return `<tr><td>${resolveUserName(aid)}</td>${cells}</tr>`;
      }).join('');

      document.getElementById('trendTable').innerHTML = `
        <table class="frozen-table trend-table">
          ${header}
          <tbody>${rows}</tbody>
        </table>
      `;

      const byAvg = insightArr.filter(x=>x.avg!=null).sort((a,b)=>b.avg-a.avg);
      const top = byAvg.slice(0,5).map(x=>`<tr><td>${x.name}</td><td>${x.count}</td><td>${pct(x.avg,1)}</td></tr>`).join('');
      const bottom = byAvg.slice(-5).map(x=>`<tr><td>${x.name}</td><td>${x.count}</td><td>${pct(x.avg,1)}</td></tr>`).join('');
      document.getElementById('topAgentsTable').innerHTML = `
        <thead><tr><th>Top Agents</th><th>Evals</th><th>Avg</th></tr></thead><tbody>${top || '<tr><td colspan="3" class="muted">No data</td></tr>'}</tbody>`;
      document.getElementById('bottomAgentsTable').innerHTML = `
        <thead><tr><th>Bottom Agents</th><th>Evals</th><th>Avg</th></tr></thead><tbody>${bottom || '<tr><td colspan="3" class="muted">No data</td></tr>'}</tbody>`;
    }

    function renderAgentInsights(){
      const data = window._insightData || [];
      const mode = document.getElementById('insightsSort').value || 'avgDesc';
      const arr = (function sort(mode, a){
        const x=[...a];
        if(mode==='avgAsc') x.sort((u,v)=>(u.avg??-1)-(v.avg??-1));
        else if(mode==='avgDesc') x.sort((u,v)=>(v.avg??-1)-(u.avg??-1));
        else if(mode==='failsDesc') x.sort((u,v)=>v.fails-u.fails);
        else if(mode==='evalsDesc') x.sort((u,v)=>v.count-u.count);
        return x;
      })(mode, data);

      const html = arr.map(a=>{
        const w = a.avg==null?0:Math.max(0,Math.min(100,a.avg));
        return `<div class="insight-row">
          <div class="insight-name">${a.name}</div>
          <div class="insight-bar-wrap"><div class="insight-bar" style="width:${w}%"></div></div>
          <div class="insight-meta">${pct(a.avg??0,1)} <span class="pill">Evals ${a.count}</span><span class="pill">Fails ${a.fails}</span></div>
        </div>`;
      }).join('');
      document.getElementById('agentInsights').innerHTML = html || '<div class="muted">No agent data.</div>';
    }

    // ===== Details =====
    async function renderDetails(){
      const c=document.getElementById('detailsContainer');
      if (!state.evals.length){ c.innerHTML = '<div class="muted">No evaluations loaded.</div>'; return; }
      c.innerHTML = '<div class="info-message">Loading evaluation details...</div>';

      const evaluationElements = await Promise.all(state.evals.map(async (e) => {
        const agent = resolveUserName(safeGet(e,'agent.id') || e.agentUserId);
        const lookup = await getCombinedLookupForEval(e);
        const formName = lookup.formName;
        const when = toUKDate(e.releaseDate || e.assignedDate || e.creationDate || e.evaluationDate || e.date || Date.now());
        const convo = e.conversationId || e.conversation?.id || '(n/a)';
        const score = getEvalPercent(e);
        const questionGroups = safeGet(e, 'answers.questionGroupScores') || [];

        let qRows = '';
        questionGroups.forEach(group => {
          (group.questionScores || []).forEach(qScore => {
            const questionText = resolveQuestionTextWithLookup(lookup,qScore);
            const answerText = resolveAnswerTextWithLookup(lookup,qScore);
            const ansScore = qScore.score ?? null;
            const qIds = [qScore.questionId, qScore.questionContextId, safeGet(qScore, 'question.id'), safeGet(qScore, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(qScore, questionObj);

            let rowClass = '';
            if (isFatal) rowClass = 'fatal-question';
            else if (isCritical) rowClass = 'critical-warning';

            let allComments = '';
            if (qScore.comments) { allComments += `<div class="comment-bubble"><strong>Evaluator Comments:</strong> ${qScore.comments}</div>`; }
            if (qScore.aiAnswer && qScore.aiAnswer.explanation) { allComments += `<div class="comment-bubble"><strong>AI Analysis:</strong> ${qScore.aiAnswer.explanation}</div>`; }

            qRows += `<tr class="${rowClass}">
              <td>${questionText}</td>
              <td>${answerText}</td>
              <td>${ansScore === null ? '-' : fmt(ansScore, 1)}</td>
              <td>${isFatal ? '<span class="badge badge-fatal">Fatal</span>' : isCritical ? '<span class="badge badge-critical">Critical</span>' : '<span class="badge badge-ok">OK</span>'}</td>
              <td>${allComments}</td>
            </tr>`;
          });
        });

        return `
          <details class="evaluation">
            <summary>${when} • <strong>${agent}</strong> — ${formName} &nbsp;&middot;&nbsp; Score: <strong>${score===null?'-':pct(score,1)}</strong> ${convo!=='(n/a)'?`&nbsp;&middot;&nbsp; Conversation: ${convo}`:''}</summary>
            <div class="table-container">
              <table class="details-table">
                <thead><tr><th>Question</th><th>Answer</th><th>Score</th><th>Flags</th><th>Comments</th></tr></thead>
                <tbody>${qRows || `<tr><td colspan="5" class="muted">No question data available.</td></tr>`}</tbody>
              </table>
            </div>
          </details>
        `;
      }));
      c.innerHTML = evaluationElements.join('');
    }

    // ===== Critical =====
    async function renderCritical(){
      const tbl=document.getElementById('criticalTable');
      if(!state.evals.length){ 
        document.getElementById('criticalSummaryKPIs').innerHTML = '';
        tbl.innerHTML='<tr><td class="muted">No evaluations loaded.</td></tr>'; 
        return; 
      }

      let totalCritical = 0;
      let totalFatal = 0;
      const fatalMap=new Map();  
      const critMap=new Map();
      
      function add(map, formName, qText, agentName){
        const key=formName+'|'+qText;
        if(!map.has(key)) map.set(key,{formName,qText,count:0,agents:new Map()});
        const o=map.get(key); o.count++; o.agents.set(agentName,(o.agents.get(agentName)||0)+1);
      }

      for (const e of state.evals){
        const lookup = await getCombinedLookupForEval(e);
        const formName = lookup.formName;
        const agentName = resolveUserName(safeGet(e,'agent.id')||e.agentUserId);
        const qGroups = safeGet(e,'answers.questionGroupScores') || [];
        qGroups.forEach(g=>{
          (g.questionScores||[]).forEach(qs=>{
            const qText = resolveQuestionTextWithLookup(lookup,qs);
            const qIds = [qs.questionId, qs.questionContextId, safeGet(qs, 'question.id'), safeGet(qs, 'question.contextId')].filter(Boolean);
            const questionObj = qIds.map(id => lookup.questionObj.get(id)).find(Boolean);
            const { isFatal, isCritical } = detectCriticalFatalQuestions(qs, questionObj);
            if(isFatal) { add(fatalMap, formName, qText, agentName); totalFatal++; }
            if(isCritical && !isFatal) { add(critMap, formName, qText, agentName); totalCritical++; }
          });
        });
      }

      document.getElementById('criticalSummaryKPIs').innerHTML = `
        <div class="critical-kpi critical">
          <div class="number">${totalCritical}</div>
          <div class="label">Total Critical Marks</div>
        </div>
        <div class="critical-kpi fatal">
          <div class="number">${totalFatal}</div>
          <div class="label">Total Fatal Marks</div>
        </div>
      `;

      const rows = [];
      function rowsFrom(map, type){
        Array.from(map.values())
          .sort((a,b)=>b.count-a.count)
          .forEach(r=>{
            const agentsArr = Array.from(r.agents.entries()).sort((a,b)=>b[1]-a[1]);
            const summaryText = `${agentsArr.length} agent${agentsArr.length!==1?'s':''} / ${r.count} mark${r.count!==1?'s':''}`;
            const agentsHtml = `<details class="agent-list">
                <summary>${summaryText}</summary>
                <div class="agent-pills">
                  ${agentsArr.map(([name,c])=>`<span class="pill">${name} × ${c}</span>`).join('')}
                </div>
              </details>`;
            rows.push(`<tr>
              <td>${r.formName}</td>
              <td>${r.qText}</td>
              <td>${type==='fatal'
                    ? '<span class="badge badge-fatal">Fatal</span>'
                    : '<span class="badge badge-critical">Critical</span>'}</td>
              <td>${r.count}</td>
              <td>${agentsHtml}</td>
            </tr>`);
          });
      }
      rowsFrom(fatalMap,'fatal'); 
      rowsFrom(critMap,'critical');

      tbl.innerHTML = `
        <thead><tr>
          <th>Form</th><th>Question</th><th>Type</th><th>Marks</th><th>Agents</th>
        </tr></thead>
        <tbody>${rows.join('') || `<tr><td colspan="5" class="muted">No critical or fatal marks found for the selected period.</td></tr>`}</tbody>`;
    }
  </script>
</body>
</html>
